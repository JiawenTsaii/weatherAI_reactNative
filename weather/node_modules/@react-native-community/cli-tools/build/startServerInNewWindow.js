"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireDefault(require("fs"));
  _fs = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
<<<<<<< HEAD
var _logger = _interopRequireDefault(require("./logger"));
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
var _findPackageDependencyDir = require("./findPackageDependencyDir");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERROR = `a dev server manually by running ${_chalk().default.bold('npm start')} or ${_chalk().default.bold('yarn start')} in other terminal window.`;
function startServerInNewWindow(port, projectRoot, reactNativePath, terminal) {
  if (!terminal) {
    _logger.default.error('Cannot start server in new windows because no terminal app was specified, use --terminal to specify, or start ' + ERROR);
    return;
=======
var _errors = require("./errors");
var _resolveNodeModuleDir = _interopRequireDefault(require("./resolveNodeModuleDir"));
var _logger = _interopRequireDefault(require("./logger"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function startServerInNewWindow(port, projectRoot, reactNativePath, terminal) {
  if (!terminal) {
    throw new _errors.CLIError('Cannot start server in new window because no terminal app was specified.');
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }

  /**
   * Set up OS-specific filenames and commands
   */
  const isWindows = /^win/.test(process.platform);
  const scriptFile = isWindows ? 'launchPackager.bat' : 'launchPackager.command';
  const packagerEnvFilename = isWindows ? '.packager.bat' : '.packager.env';
<<<<<<< HEAD
  const packagerEnvFileExportContent = isWindows ? `set RCT_METRO_PORT=${port}\nset PROJECT_ROOT=${projectRoot}\nset REACT_NATIVE_PATH=${reactNativePath}` : `export RCT_METRO_PORT=${port}\nexport PROJECT_ROOT="${projectRoot}"\nexport REACT_NATIVE_PATH="${reactNativePath}"`;
  let generatedPath = (0, _findPackageDependencyDir.findPackageDependencyDir)('.generated', {
    startDir: projectRoot
  });
  if (!generatedPath) {
    const newPath = _path().default.join(projectRoot, 'node_modules', '.generated');
    _fs().default.mkdirSync(newPath, {
      recursive: true,
      mode: 0o755
    });
    generatedPath = newPath;
  }
=======
  const packagerEnvFileExportContent = isWindows ? `set RCT_METRO_PORT=${port}\nset PROJECT_ROOT=${projectRoot}\nset REACT_NATIVE_PATH=${reactNativePath}` : `export RCT_METRO_PORT=${port}\nexport PROJECT_ROOT=${projectRoot}\nexport REACT_NATIVE_PATH=${reactNativePath}`;
  const nodeModulesPath = (0, _resolveNodeModuleDir.default)(projectRoot, '.bin');
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  const cliPluginMetroPath = _path().default.join(_path().default.dirname(require.resolve('@react-native-community/cli-tools/package.json')), 'build');

  /**
   * Set up the `.packager.(env|bat)` file to ensure the packager starts on the right port and in right directory.
   */
<<<<<<< HEAD
  const packagerEnvFile = _path().default.join(generatedPath, `${packagerEnvFilename}`);
=======
  const packagerEnvFile = _path().default.join(nodeModulesPath, `${packagerEnvFilename}`);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  /**
   * Set up the `launchPackager.(command|bat)` file.
   * It lives next to `.packager.(bat|env)`
   */
<<<<<<< HEAD
  const launchPackagerScript = _path().default.join(generatedPath, scriptFile);
=======
  const launchPackagerScript = _path().default.join(nodeModulesPath, scriptFile);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  const procConfig = {
    cwd: _path().default.dirname(packagerEnvFile)
  };

  /**
   * Ensure we overwrite file by passing the `w` flag
   */
  _fs().default.writeFileSync(packagerEnvFile, packagerEnvFileExportContent, {
    encoding: 'utf8',
    flag: 'w'
  });

  /**
<<<<<<< HEAD
   * Copy files into `node_modules/.generated`.
=======
   * Copy files into `node_modules/.bin`.
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
   */

  try {
    if (isWindows) {
<<<<<<< HEAD
      _fs().default.copyFileSync(_path().default.join(cliPluginMetroPath, 'launchPackager.bat'), _path().default.join(generatedPath, 'launchPackager.bat'));
    } else {
      _fs().default.copyFileSync(_path().default.join(cliPluginMetroPath, 'launchPackager.command'), _path().default.join(generatedPath, 'launchPackager.command'));
    }
  } catch (error) {
    _logger.default.error(`Couldn't copy the script for running bundler. Please check if the "${scriptFile}" file exists in the "node_modules/@react-native-community/cli-tools" folder, or start ` + ERROR, error);
    return;
=======
      _fs().default.copyFileSync(_path().default.join(cliPluginMetroPath, 'launchPackager.bat'), _path().default.join(nodeModulesPath, 'launchPackager.bat'));
    } else {
      _fs().default.copyFileSync(_path().default.join(cliPluginMetroPath, 'launchPackager.command'), _path().default.join(nodeModulesPath, 'launchPackager.command'));
    }
  } catch (error) {
    return new _errors.CLIError(`Couldn't copy the script for running bundler. Please check if the "${scriptFile}" file exists in the "node_modules/@react-native-community/cli-tools" folder and try again.`, error);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }
  if (process.platform === 'darwin') {
    try {
      return _execa().default.sync('open', ['-a', terminal, launchPackagerScript], procConfig);
    } catch (error) {
      return _execa().default.sync('open', [launchPackagerScript], procConfig);
    }
  }
  if (process.platform === 'linux') {
    try {
      return _execa().default.sync(terminal, ['-e', `sh ${launchPackagerScript}`], {
        ...procConfig,
        detached: true
      });
    } catch (error) {
      // By default, the child shell process will be attached to the parent
      return _execa().default.sync('sh', [launchPackagerScript], procConfig);
    }
  }
  if (isWindows) {
    // Awaiting this causes the CLI to hang indefinitely, so this must execute without await.
    return (0, _execa().default)(terminal, ['/C', launchPackagerScript], {
      ...procConfig,
      detached: true,
      stdio: 'ignore'
    });
  }
<<<<<<< HEAD
  _logger.default.error(`Cannot start the packager. Unknown platform ${process.platform}. Try starting ` + ERROR);
=======
  _logger.default.error(`Cannot start the packager. Unknown platform ${process.platform}`);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  return;
}
var _default = startServerInNewWindow;
exports.default = _default;

//# sourceMappingURL=startServerInNewWindow.ts.map