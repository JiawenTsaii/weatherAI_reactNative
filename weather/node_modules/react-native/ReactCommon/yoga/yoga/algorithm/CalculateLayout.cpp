/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <algorithm>
#include <atomic>
#include <cfloat>
#include <cmath>
#include <cstring>

#include <yoga/Yoga.h>

<<<<<<< HEAD
#include <yoga/algorithm/AbsoluteLayout.h>
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
#include <yoga/algorithm/Align.h>
#include <yoga/algorithm/Baseline.h>
#include <yoga/algorithm/BoundAxis.h>
#include <yoga/algorithm/Cache.h>
#include <yoga/algorithm/CalculateLayout.h>
#include <yoga/algorithm/FlexDirection.h>
#include <yoga/algorithm/FlexLine.h>
#include <yoga/algorithm/PixelGrid.h>
<<<<<<< HEAD
#include <yoga/algorithm/SizingMode.h>
#include <yoga/algorithm/TrailingPosition.h>
#include <yoga/debug/AssertFatal.h>
#include <yoga/debug/Log.h>
=======
#include <yoga/algorithm/ResolveValue.h>
#include <yoga/debug/AssertFatal.h>
#include <yoga/debug/Log.h>
#include <yoga/debug/NodeToString.h>
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
#include <yoga/event/event.h>
#include <yoga/node/Node.h>
#include <yoga/numeric/Comparison.h>
#include <yoga/numeric/FloatOptional.h>

namespace facebook::yoga {

std::atomic<uint32_t> gCurrentGenerationCount(0);

<<<<<<< HEAD
static void constrainMaxSizeForMode(
    const yoga::Node* node,
    FlexDirection axis,
    float ownerAxisSize,
    float ownerWidth,
    /*in_out*/ SizingMode* mode,
    /*in_out*/ float* size) {
  const FloatOptional maxSize =
      node->style().maxDimension(dimension(axis)).resolve(ownerAxisSize) +
      FloatOptional(node->style().computeMarginForAxis(axis, ownerWidth));
  switch (*mode) {
    case SizingMode::StretchFit:
    case SizingMode::FitContent:
=======
bool calculateLayoutInternal(
    yoga::Node* const node,
    const float availableWidth,
    const float availableHeight,
    const Direction ownerDirection,
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
    const float ownerWidth,
    const float ownerHeight,
    const bool performLayout,
    const LayoutPassReason reason,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount);

static inline float dimensionWithMargin(
    const yoga::Node* const node,
    const FlexDirection axis,
    const float widthSize) {
  return node->getLayout().measuredDimension(dimension(axis)) +
      (node->getLeadingMargin(axis, widthSize) +
       node->getTrailingMargin(axis, widthSize))
          .unwrap();
}

static inline bool styleDefinesDimension(
    const yoga::Node* const node,
    const FlexDirection axis,
    const float ownerSize) {
  bool isUndefined =
      yoga::isUndefined(node->getResolvedDimension(dimension(axis)).value);

  auto resolvedDimension = node->getResolvedDimension(dimension(axis));
  return !(
      resolvedDimension.unit == YGUnitAuto ||
      resolvedDimension.unit == YGUnitUndefined ||
      (resolvedDimension.unit == YGUnitPoint && !isUndefined &&
       resolvedDimension.value < 0.0f) ||
      (resolvedDimension.unit == YGUnitPercent && !isUndefined &&
       (resolvedDimension.value < 0.0f || yoga::isUndefined(ownerSize))));
}

static inline bool isLayoutDimensionDefined(
    const yoga::Node* const node,
    const FlexDirection axis) {
  const float value = node->getLayout().measuredDimension(dimension(axis));
  return !yoga::isUndefined(value) && value >= 0.0f;
}

static void setChildTrailingPosition(
    const yoga::Node* const node,
    yoga::Node* const child,
    const FlexDirection axis) {
  const float size = child->getLayout().measuredDimension(dimension(axis));
  child->setLayoutPosition(
      node->getLayout().measuredDimension(dimension(axis)) - size -
          child->getLayout().position[leadingEdge(axis)],
      trailingEdge(axis));
}

static void constrainMaxSizeForMode(
    const yoga::Node* const node,
    const enum FlexDirection axis,
    const float ownerAxisSize,
    const float ownerWidth,
    MeasureMode* mode,
    float* size) {
  const FloatOptional maxSize =
      yoga::resolveValue(
          node->getStyle().maxDimension(dimension(axis)), ownerAxisSize) +
      FloatOptional(node->getMarginForAxis(axis, ownerWidth));
  switch (*mode) {
    case MeasureMode::Exactly:
    case MeasureMode::AtMost:
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      *size = (maxSize.isUndefined() || *size < maxSize.unwrap())
          ? *size
          : maxSize.unwrap();
      break;
<<<<<<< HEAD
    case SizingMode::MaxContent:
      if (maxSize.isDefined()) {
        *mode = SizingMode::FitContent;
=======
    case MeasureMode::Undefined:
      if (!maxSize.isUndefined()) {
        *mode = MeasureMode::AtMost;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        *size = maxSize.unwrap();
      }
      break;
  }
}

static void computeFlexBasisForChild(
    const yoga::Node* const node,
    yoga::Node* const child,
    const float width,
<<<<<<< HEAD
    const SizingMode widthMode,
    const float height,
    const float ownerWidth,
    const float ownerHeight,
    const SizingMode heightMode,
=======
    const MeasureMode widthMode,
    const float height,
    const float ownerWidth,
    const float ownerHeight,
    const MeasureMode heightMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const Direction direction,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount) {
  const FlexDirection mainAxis =
<<<<<<< HEAD
      resolveDirection(node->style().flexDirection(), direction);
=======
      resolveDirection(node->getStyle().flexDirection(), direction);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  const bool isMainAxisRow = isRow(mainAxis);
  const float mainAxisSize = isMainAxisRow ? width : height;
  const float mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight;

  float childWidth;
  float childHeight;
<<<<<<< HEAD
  SizingMode childWidthSizingMode;
  SizingMode childHeightSizingMode;

  const FloatOptional resolvedFlexBasis =
      child->resolveFlexBasisPtr().resolve(mainAxisownerSize);
  const bool isRowStyleDimDefined =
      child->hasDefiniteLength(Dimension::Width, ownerWidth);
  const bool isColumnStyleDimDefined =
      child->hasDefiniteLength(Dimension::Height, ownerHeight);

  if (resolvedFlexBasis.isDefined() && yoga::isDefined(mainAxisSize)) {
=======
  MeasureMode childWidthMeasureMode;
  MeasureMode childHeightMeasureMode;

  const FloatOptional resolvedFlexBasis =
      yoga::resolveValue(child->resolveFlexBasisPtr(), mainAxisownerSize);
  const bool isRowStyleDimDefined =
      styleDefinesDimension(child, FlexDirection::Row, ownerWidth);
  const bool isColumnStyleDimDefined =
      styleDefinesDimension(child, FlexDirection::Column, ownerHeight);

  if (!resolvedFlexBasis.isUndefined() && !yoga::isUndefined(mainAxisSize)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    if (child->getLayout().computedFlexBasis.isUndefined() ||
        (child->getConfig()->isExperimentalFeatureEnabled(
             ExperimentalFeature::WebFlexBasis) &&
         child->getLayout().computedFlexBasisGeneration != generationCount)) {
      const FloatOptional paddingAndBorder =
          FloatOptional(paddingAndBorderForAxis(child, mainAxis, ownerWidth));
      child->setLayoutComputedFlexBasis(
          yoga::maxOrDefined(resolvedFlexBasis, paddingAndBorder));
    }
  } else if (isMainAxisRow && isRowStyleDimDefined) {
    // The width is definite, so use that as the flex basis.
    const FloatOptional paddingAndBorder = FloatOptional(
        paddingAndBorderForAxis(child, FlexDirection::Row, ownerWidth));

    child->setLayoutComputedFlexBasis(yoga::maxOrDefined(
<<<<<<< HEAD
        child->getResolvedDimension(Dimension::Width).resolve(ownerWidth),
=======
        yoga::resolveValue(
            child->getResolvedDimension(YGDimensionWidth), ownerWidth),
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        paddingAndBorder));
  } else if (!isMainAxisRow && isColumnStyleDimDefined) {
    // The height is definite, so use that as the flex basis.
    const FloatOptional paddingAndBorder = FloatOptional(
        paddingAndBorderForAxis(child, FlexDirection::Column, ownerWidth));
    child->setLayoutComputedFlexBasis(yoga::maxOrDefined(
<<<<<<< HEAD
        child->getResolvedDimension(Dimension::Height).resolve(ownerHeight),
=======
        yoga::resolveValue(
            child->getResolvedDimension(YGDimensionHeight), ownerHeight),
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        paddingAndBorder));
  } else {
    // Compute the flex basis and hypothetical main size (i.e. the clamped flex
    // basis).
    childWidth = YGUndefined;
    childHeight = YGUndefined;
<<<<<<< HEAD
    childWidthSizingMode = SizingMode::MaxContent;
    childHeightSizingMode = SizingMode::MaxContent;

    auto marginRow =
        child->style().computeMarginForAxis(FlexDirection::Row, ownerWidth);
    auto marginColumn =
        child->style().computeMarginForAxis(FlexDirection::Column, ownerWidth);

    if (isRowStyleDimDefined) {
      childWidth = child->getResolvedDimension(Dimension::Width)
                       .resolve(ownerWidth)
                       .unwrap() +
          marginRow;
      childWidthSizingMode = SizingMode::StretchFit;
    }
    if (isColumnStyleDimDefined) {
      childHeight = child->getResolvedDimension(Dimension::Height)
                        .resolve(ownerHeight)
                        .unwrap() +
          marginColumn;
      childHeightSizingMode = SizingMode::StretchFit;
=======
    childWidthMeasureMode = MeasureMode::Undefined;
    childHeightMeasureMode = MeasureMode::Undefined;

    auto marginRow =
        child->getMarginForAxis(FlexDirection::Row, ownerWidth).unwrap();
    auto marginColumn =
        child->getMarginForAxis(FlexDirection::Column, ownerWidth).unwrap();

    if (isRowStyleDimDefined) {
      childWidth =
          yoga::resolveValue(
              child->getResolvedDimension(YGDimensionWidth), ownerWidth)
              .unwrap() +
          marginRow;
      childWidthMeasureMode = MeasureMode::Exactly;
    }
    if (isColumnStyleDimDefined) {
      childHeight =
          yoga::resolveValue(
              child->getResolvedDimension(YGDimensionHeight), ownerHeight)
              .unwrap() +
          marginColumn;
      childHeightMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    }

    // The W3C spec doesn't say anything about the 'overflow' property, but all
    // major browsers appear to implement the following logic.
<<<<<<< HEAD
    if ((!isMainAxisRow && node->style().overflow() == Overflow::Scroll) ||
        node->style().overflow() != Overflow::Scroll) {
      if (yoga::isUndefined(childWidth) && yoga::isDefined(width)) {
        childWidth = width;
        childWidthSizingMode = SizingMode::FitContent;
      }
    }

    if ((isMainAxisRow && node->style().overflow() == Overflow::Scroll) ||
        node->style().overflow() != Overflow::Scroll) {
      if (yoga::isUndefined(childHeight) && yoga::isDefined(height)) {
        childHeight = height;
        childHeightSizingMode = SizingMode::FitContent;
      }
    }

    const auto& childStyle = child->style();
    if (childStyle.aspectRatio().isDefined()) {
      if (!isMainAxisRow && childWidthSizingMode == SizingMode::StretchFit) {
        childHeight = marginColumn +
            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
        childHeightSizingMode = SizingMode::StretchFit;
      } else if (
          isMainAxisRow && childHeightSizingMode == SizingMode::StretchFit) {
        childWidth = marginRow +
            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
        childWidthSizingMode = SizingMode::StretchFit;
=======
    if ((!isMainAxisRow && node->getStyle().overflow() == Overflow::Scroll) ||
        node->getStyle().overflow() != Overflow::Scroll) {
      if (yoga::isUndefined(childWidth) && !yoga::isUndefined(width)) {
        childWidth = width;
        childWidthMeasureMode = MeasureMode::AtMost;
      }
    }

    if ((isMainAxisRow && node->getStyle().overflow() == Overflow::Scroll) ||
        node->getStyle().overflow() != Overflow::Scroll) {
      if (yoga::isUndefined(childHeight) && !yoga::isUndefined(height)) {
        childHeight = height;
        childHeightMeasureMode = MeasureMode::AtMost;
      }
    }

    const auto& childStyle = child->getStyle();
    if (!childStyle.aspectRatio().isUndefined()) {
      if (!isMainAxisRow && childWidthMeasureMode == MeasureMode::Exactly) {
        childHeight = marginColumn +
            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
        childHeightMeasureMode = MeasureMode::Exactly;
      } else if (
          isMainAxisRow && childHeightMeasureMode == MeasureMode::Exactly) {
        childWidth = marginRow +
            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
        childWidthMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    }

    // If child has no defined size in the cross axis and is set to stretch, set
    // the cross axis to be measured exactly with the available inner width

    const bool hasExactWidth =
<<<<<<< HEAD
        yoga::isDefined(width) && widthMode == SizingMode::StretchFit;
    const bool childWidthStretch =
        resolveChildAlignment(node, child) == Align::Stretch &&
        childWidthSizingMode != SizingMode::StretchFit;
    if (!isMainAxisRow && !isRowStyleDimDefined && hasExactWidth &&
        childWidthStretch) {
      childWidth = width;
      childWidthSizingMode = SizingMode::StretchFit;
      if (childStyle.aspectRatio().isDefined()) {
        childHeight =
            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
        childHeightSizingMode = SizingMode::StretchFit;
=======
        !yoga::isUndefined(width) && widthMode == MeasureMode::Exactly;
    const bool childWidthStretch =
        resolveChildAlignment(node, child) == Align::Stretch &&
        childWidthMeasureMode != MeasureMode::Exactly;
    if (!isMainAxisRow && !isRowStyleDimDefined && hasExactWidth &&
        childWidthStretch) {
      childWidth = width;
      childWidthMeasureMode = MeasureMode::Exactly;
      if (!childStyle.aspectRatio().isUndefined()) {
        childHeight =
            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
        childHeightMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    }

    const bool hasExactHeight =
<<<<<<< HEAD
        yoga::isDefined(height) && heightMode == SizingMode::StretchFit;
    const bool childHeightStretch =
        resolveChildAlignment(node, child) == Align::Stretch &&
        childHeightSizingMode != SizingMode::StretchFit;
    if (isMainAxisRow && !isColumnStyleDimDefined && hasExactHeight &&
        childHeightStretch) {
      childHeight = height;
      childHeightSizingMode = SizingMode::StretchFit;

      if (childStyle.aspectRatio().isDefined()) {
        childWidth =
            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
        childWidthSizingMode = SizingMode::StretchFit;
=======
        !yoga::isUndefined(height) && heightMode == MeasureMode::Exactly;
    const bool childHeightStretch =
        resolveChildAlignment(node, child) == Align::Stretch &&
        childHeightMeasureMode != MeasureMode::Exactly;
    if (isMainAxisRow && !isColumnStyleDimDefined && hasExactHeight &&
        childHeightStretch) {
      childHeight = height;
      childHeightMeasureMode = MeasureMode::Exactly;

      if (!childStyle.aspectRatio().isUndefined()) {
        childWidth =
            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
        childWidthMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    }

    constrainMaxSizeForMode(
        child,
        FlexDirection::Row,
        ownerWidth,
        ownerWidth,
<<<<<<< HEAD
        &childWidthSizingMode,
=======
        &childWidthMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        &childWidth);
    constrainMaxSizeForMode(
        child,
        FlexDirection::Column,
        ownerHeight,
        ownerWidth,
<<<<<<< HEAD
        &childHeightSizingMode,
=======
        &childHeightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        &childHeight);

    // Measure the child
    calculateLayoutInternal(
        child,
        childWidth,
        childHeight,
        direction,
<<<<<<< HEAD
        childWidthSizingMode,
        childHeightSizingMode,
=======
        childWidthMeasureMode,
        childHeightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        ownerWidth,
        ownerHeight,
        false,
        LayoutPassReason::kMeasureChild,
        layoutMarkerData,
        depth,
        generationCount);

    child->setLayoutComputedFlexBasis(FloatOptional(yoga::maxOrDefined(
        child->getLayout().measuredDimension(dimension(mainAxis)),
        paddingAndBorderForAxis(child, mainAxis, ownerWidth))));
  }
  child->setLayoutComputedFlexBasisGeneration(generationCount);
}

<<<<<<< HEAD
=======
static void layoutAbsoluteChild(
    const yoga::Node* const node,
    yoga::Node* const child,
    const float width,
    const MeasureMode widthMode,
    const float height,
    const Direction direction,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount) {
  const FlexDirection mainAxis =
      resolveDirection(node->getStyle().flexDirection(), direction);
  const FlexDirection crossAxis = resolveCrossDirection(mainAxis, direction);
  const bool isMainAxisRow = isRow(mainAxis);

  float childWidth = YGUndefined;
  float childHeight = YGUndefined;
  MeasureMode childWidthMeasureMode = MeasureMode::Undefined;
  MeasureMode childHeightMeasureMode = MeasureMode::Undefined;

  auto marginRow = child->getMarginForAxis(FlexDirection::Row, width).unwrap();
  auto marginColumn =
      child->getMarginForAxis(FlexDirection::Column, width).unwrap();

  if (styleDefinesDimension(child, FlexDirection::Row, width)) {
    childWidth =
        yoga::resolveValue(child->getResolvedDimension(YGDimensionWidth), width)
            .unwrap() +
        marginRow;
  } else {
    // If the child doesn't have a specified width, compute the width based on
    // the left/right offsets if they're defined.
    if (child->isLeadingPositionDefined(FlexDirection::Row) &&
        child->isTrailingPosDefined(FlexDirection::Row)) {
      childWidth = node->getLayout().measuredDimension(YGDimensionWidth) -
          (node->getLeadingBorder(FlexDirection::Row) +
           node->getTrailingBorder(FlexDirection::Row)) -
          (child->getLeadingPosition(FlexDirection::Row, width) +
           child->getTrailingPosition(FlexDirection::Row, width))
              .unwrap();
      childWidth =
          boundAxis(child, FlexDirection::Row, childWidth, width, width);
    }
  }

  if (styleDefinesDimension(child, FlexDirection::Column, height)) {
    childHeight = yoga::resolveValue(
                      child->getResolvedDimension(YGDimensionHeight), height)
                      .unwrap() +
        marginColumn;
  } else {
    // If the child doesn't have a specified height, compute the height based on
    // the top/bottom offsets if they're defined.
    if (child->isLeadingPositionDefined(FlexDirection::Column) &&
        child->isTrailingPosDefined(FlexDirection::Column)) {
      childHeight = node->getLayout().measuredDimension(YGDimensionHeight) -
          (node->getLeadingBorder(FlexDirection::Column) +
           node->getTrailingBorder(FlexDirection::Column)) -
          (child->getLeadingPosition(FlexDirection::Column, height) +
           child->getTrailingPosition(FlexDirection::Column, height))
              .unwrap();
      childHeight =
          boundAxis(child, FlexDirection::Column, childHeight, height, width);
    }
  }

  // Exactly one dimension needs to be defined for us to be able to do aspect
  // ratio calculation. One dimension being the anchor and the other being
  // flexible.
  const auto& childStyle = child->getStyle();
  if (yoga::isUndefined(childWidth) ^ yoga::isUndefined(childHeight)) {
    if (!childStyle.aspectRatio().isUndefined()) {
      if (yoga::isUndefined(childWidth)) {
        childWidth = marginRow +
            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
      } else if (yoga::isUndefined(childHeight)) {
        childHeight = marginColumn +
            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
      }
    }
  }

  // If we're still missing one or the other dimension, measure the content.
  if (yoga::isUndefined(childWidth) || yoga::isUndefined(childHeight)) {
    childWidthMeasureMode = yoga::isUndefined(childWidth)
        ? MeasureMode::Undefined
        : MeasureMode::Exactly;
    childHeightMeasureMode = yoga::isUndefined(childHeight)
        ? MeasureMode::Undefined
        : MeasureMode::Exactly;

    // If the size of the owner is defined then try to constrain the absolute
    // child to that size as well. This allows text within the absolute child to
    // wrap to the size of its owner. This is the same behavior as many browsers
    // implement.
    if (!isMainAxisRow && yoga::isUndefined(childWidth) &&
        widthMode != MeasureMode::Undefined && !yoga::isUndefined(width) &&
        width > 0) {
      childWidth = width;
      childWidthMeasureMode = MeasureMode::AtMost;
    }

    calculateLayoutInternal(
        child,
        childWidth,
        childHeight,
        direction,
        childWidthMeasureMode,
        childHeightMeasureMode,
        childWidth,
        childHeight,
        false,
        LayoutPassReason::kAbsMeasureChild,
        layoutMarkerData,
        depth,
        generationCount);
    childWidth = child->getLayout().measuredDimension(YGDimensionWidth) +
        child->getMarginForAxis(FlexDirection::Row, width).unwrap();
    childHeight = child->getLayout().measuredDimension(YGDimensionHeight) +
        child->getMarginForAxis(FlexDirection::Column, width).unwrap();
  }

  calculateLayoutInternal(
      child,
      childWidth,
      childHeight,
      direction,
      MeasureMode::Exactly,
      MeasureMode::Exactly,
      childWidth,
      childHeight,
      true,
      LayoutPassReason::kAbsLayout,
      layoutMarkerData,
      depth,
      generationCount);

  if (child->isTrailingPosDefined(mainAxis) &&
      !child->isLeadingPositionDefined(mainAxis)) {
    child->setLayoutPosition(
        node->getLayout().measuredDimension(dimension(mainAxis)) -
            child->getLayout().measuredDimension(dimension(mainAxis)) -
            node->getTrailingBorder(mainAxis) -
            child->getTrailingMargin(mainAxis, isMainAxisRow ? width : height)
                .unwrap() -
            child->getTrailingPosition(mainAxis, isMainAxisRow ? width : height)
                .unwrap(),
        leadingEdge(mainAxis));
  } else if (
      !child->isLeadingPositionDefined(mainAxis) &&
      node->getStyle().justifyContent() == Justify::Center) {
    child->setLayoutPosition(
        (node->getLayout().measuredDimension(dimension(mainAxis)) -
         child->getLayout().measuredDimension(dimension(mainAxis))) /
            2.0f,
        leadingEdge(mainAxis));
  } else if (
      !child->isLeadingPositionDefined(mainAxis) &&
      node->getStyle().justifyContent() == Justify::FlexEnd) {
    child->setLayoutPosition(
        (node->getLayout().measuredDimension(dimension(mainAxis)) -
         child->getLayout().measuredDimension(dimension(mainAxis))),
        leadingEdge(mainAxis));
  } else if (
      node->getConfig()->isExperimentalFeatureEnabled(
          ExperimentalFeature::AbsolutePercentageAgainstPaddingEdge) &&
      child->isLeadingPositionDefined(mainAxis)) {
    child->setLayoutPosition(
        child->getLeadingPosition(
                 mainAxis,
                 node->getLayout().measuredDimension(dimension(mainAxis)))
                .unwrap() +
            node->getLeadingBorder(mainAxis) +
            child
                ->getLeadingMargin(
                    mainAxis,
                    node->getLayout().measuredDimension(dimension(mainAxis)))
                .unwrap(),
        leadingEdge(mainAxis));
  }

  if (child->isTrailingPosDefined(crossAxis) &&
      !child->isLeadingPositionDefined(crossAxis)) {
    child->setLayoutPosition(
        node->getLayout().measuredDimension(dimension(crossAxis)) -
            child->getLayout().measuredDimension(dimension(crossAxis)) -
            node->getTrailingBorder(crossAxis) -
            child->getTrailingMargin(crossAxis, isMainAxisRow ? height : width)
                .unwrap() -
            child
                ->getTrailingPosition(crossAxis, isMainAxisRow ? height : width)
                .unwrap(),
        leadingEdge(crossAxis));

  } else if (
      !child->isLeadingPositionDefined(crossAxis) &&
      resolveChildAlignment(node, child) == Align::Center) {
    child->setLayoutPosition(
        (node->getLayout().measuredDimension(dimension(crossAxis)) -
         child->getLayout().measuredDimension(dimension(crossAxis))) /
            2.0f,
        leadingEdge(crossAxis));
  } else if (
      !child->isLeadingPositionDefined(crossAxis) &&
      ((resolveChildAlignment(node, child) == Align::FlexEnd) ^
       (node->getStyle().flexWrap() == Wrap::WrapReverse))) {
    child->setLayoutPosition(
        (node->getLayout().measuredDimension(dimension(crossAxis)) -
         child->getLayout().measuredDimension(dimension(crossAxis))),
        leadingEdge(crossAxis));
  } else if (
      node->getConfig()->isExperimentalFeatureEnabled(
          ExperimentalFeature::AbsolutePercentageAgainstPaddingEdge) &&
      child->isLeadingPositionDefined(crossAxis)) {
    child->setLayoutPosition(
        child->getLeadingPosition(
                 crossAxis,
                 node->getLayout().measuredDimension(dimension(crossAxis)))
                .unwrap() +
            node->getLeadingBorder(crossAxis) +
            child
                ->getLeadingMargin(
                    crossAxis,
                    node->getLayout().measuredDimension(dimension(crossAxis)))
                .unwrap(),
        leadingEdge(crossAxis));
  }
}

>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
static void measureNodeWithMeasureFunc(
    yoga::Node* const node,
    float availableWidth,
    float availableHeight,
<<<<<<< HEAD
    const SizingMode widthSizingMode,
    const SizingMode heightSizingMode,
=======
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float ownerWidth,
    const float ownerHeight,
    LayoutData& layoutMarkerData,
    const LayoutPassReason reason) {
  yoga::assertFatalWithNode(
      node,
      node->hasMeasureFunc(),
      "Expected node to have custom measure function");

<<<<<<< HEAD
  if (widthSizingMode == SizingMode::MaxContent) {
    availableWidth = YGUndefined;
  }
  if (heightSizingMode == SizingMode::MaxContent) {
    availableHeight = YGUndefined;
  }

  const auto& layout = node->getLayout();
  const float paddingAndBorderAxisRow = layout.padding(PhysicalEdge::Left) +
      layout.padding(PhysicalEdge::Right) + layout.border(PhysicalEdge::Left) +
      layout.border(PhysicalEdge::Right);
  const float paddingAndBorderAxisColumn = layout.padding(PhysicalEdge::Top) +
      layout.padding(PhysicalEdge::Bottom) + layout.border(PhysicalEdge::Top) +
      layout.border(PhysicalEdge::Bottom);
=======
  if (widthMeasureMode == MeasureMode::Undefined) {
    availableWidth = YGUndefined;
  }
  if (heightMeasureMode == MeasureMode::Undefined) {
    availableHeight = YGUndefined;
  }

  const auto& padding = node->getLayout().padding;
  const auto& border = node->getLayout().border;
  const float paddingAndBorderAxisRow = padding[YGEdgeLeft] +
      padding[YGEdgeRight] + border[YGEdgeLeft] + border[YGEdgeRight];
  const float paddingAndBorderAxisColumn = padding[YGEdgeTop] +
      padding[YGEdgeBottom] + border[YGEdgeTop] + border[YGEdgeBottom];
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  // We want to make sure we don't call measure with negative size
  const float innerWidth = yoga::isUndefined(availableWidth)
      ? availableWidth
<<<<<<< HEAD
      : yoga::maxOrDefined(0.0f, availableWidth - paddingAndBorderAxisRow);
  const float innerHeight = yoga::isUndefined(availableHeight)
      ? availableHeight
      : yoga::maxOrDefined(0.0f, availableHeight - paddingAndBorderAxisColumn);

  if (widthSizingMode == SizingMode::StretchFit &&
      heightSizingMode == SizingMode::StretchFit) {
=======
      : yoga::maxOrDefined(0, availableWidth - paddingAndBorderAxisRow);
  const float innerHeight = yoga::isUndefined(availableHeight)
      ? availableHeight
      : yoga::maxOrDefined(0, availableHeight - paddingAndBorderAxisColumn);

  if (widthMeasureMode == MeasureMode::Exactly &&
      heightMeasureMode == MeasureMode::Exactly) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    // Don't bother sizing the text if both dimensions are already defined.
    node->setLayoutMeasuredDimension(
        boundAxis(
            node, FlexDirection::Row, availableWidth, ownerWidth, ownerWidth),
<<<<<<< HEAD
        Dimension::Width);
=======
        YGDimensionWidth);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            FlexDirection::Column,
            availableHeight,
            ownerHeight,
            ownerWidth),
<<<<<<< HEAD
        Dimension::Height);
=======
        YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  } else {
    Event::publish<Event::MeasureCallbackStart>(node);

    // Measure the text under the current constraints.
    const YGSize measuredSize = node->measure(
<<<<<<< HEAD
        innerWidth,
        measureMode(widthSizingMode),
        innerHeight,
        measureMode(heightSizingMode));
=======
        innerWidth, widthMeasureMode, innerHeight, heightMeasureMode);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    layoutMarkerData.measureCallbacks += 1;
    layoutMarkerData.measureCallbackReasonsCount[static_cast<size_t>(reason)] +=
        1;

    Event::publish<Event::MeasureCallbackEnd>(
        node,
        {innerWidth,
<<<<<<< HEAD
         unscopedEnum(measureMode(widthSizingMode)),
         innerHeight,
         unscopedEnum(measureMode(heightSizingMode)),
=======
         unscopedEnum(widthMeasureMode),
         innerHeight,
         unscopedEnum(heightMeasureMode),
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
         measuredSize.width,
         measuredSize.height,
         reason});

    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            FlexDirection::Row,
<<<<<<< HEAD
            (widthSizingMode == SizingMode::MaxContent ||
             widthSizingMode == SizingMode::FitContent)
=======
            (widthMeasureMode == MeasureMode::Undefined ||
             widthMeasureMode == MeasureMode::AtMost)
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                ? measuredSize.width + paddingAndBorderAxisRow
                : availableWidth,
            ownerWidth,
            ownerWidth),
<<<<<<< HEAD
        Dimension::Width);
=======
        YGDimensionWidth);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            FlexDirection::Column,
<<<<<<< HEAD
            (heightSizingMode == SizingMode::MaxContent ||
             heightSizingMode == SizingMode::FitContent)
=======
            (heightMeasureMode == MeasureMode::Undefined ||
             heightMeasureMode == MeasureMode::AtMost)
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                ? measuredSize.height + paddingAndBorderAxisColumn
                : availableHeight,
            ownerHeight,
            ownerWidth),
<<<<<<< HEAD
        Dimension::Height);
=======
        YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }
}

// For nodes with no children, use the available values if they were provided,
// or the minimum size as indicated by the padding and border sizes.
static void measureNodeWithoutChildren(
    yoga::Node* const node,
    const float availableWidth,
    const float availableHeight,
<<<<<<< HEAD
    const SizingMode widthSizingMode,
    const SizingMode heightSizingMode,
    const float ownerWidth,
    const float ownerHeight) {
  const auto& layout = node->getLayout();

  float width = availableWidth;
  if (widthSizingMode == SizingMode::MaxContent ||
      widthSizingMode == SizingMode::FitContent) {
    width = layout.padding(PhysicalEdge::Left) +
        layout.padding(PhysicalEdge::Right) +
        layout.border(PhysicalEdge::Left) + layout.border(PhysicalEdge::Right);
  }
  node->setLayoutMeasuredDimension(
      boundAxis(node, FlexDirection::Row, width, ownerWidth, ownerWidth),
      Dimension::Width);

  float height = availableHeight;
  if (heightSizingMode == SizingMode::MaxContent ||
      heightSizingMode == SizingMode::FitContent) {
    height = layout.padding(PhysicalEdge::Top) +
        layout.padding(PhysicalEdge::Bottom) +
        layout.border(PhysicalEdge::Top) + layout.border(PhysicalEdge::Bottom);
  }
  node->setLayoutMeasuredDimension(
      boundAxis(node, FlexDirection::Column, height, ownerHeight, ownerWidth),
      Dimension::Height);
=======
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
    const float ownerWidth,
    const float ownerHeight) {
  const auto& padding = node->getLayout().padding;
  const auto& border = node->getLayout().border;

  float width = availableWidth;
  if (widthMeasureMode == MeasureMode::Undefined ||
      widthMeasureMode == MeasureMode::AtMost) {
    width = padding[YGEdgeLeft] + padding[YGEdgeRight] + border[YGEdgeLeft] +
        border[YGEdgeRight];
  }
  node->setLayoutMeasuredDimension(
      boundAxis(node, FlexDirection::Row, width, ownerWidth, ownerWidth),
      YGDimensionWidth);

  float height = availableHeight;
  if (heightMeasureMode == MeasureMode::Undefined ||
      heightMeasureMode == MeasureMode::AtMost) {
    height = padding[YGEdgeTop] + padding[YGEdgeBottom] + border[YGEdgeTop] +
        border[YGEdgeBottom];
  }
  node->setLayoutMeasuredDimension(
      boundAxis(node, FlexDirection::Column, height, ownerHeight, ownerWidth),
      YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
}

static bool measureNodeWithFixedSize(
    yoga::Node* const node,
    const float availableWidth,
    const float availableHeight,
<<<<<<< HEAD
    const SizingMode widthSizingMode,
    const SizingMode heightSizingMode,
    const float ownerWidth,
    const float ownerHeight) {
  if ((yoga::isDefined(availableWidth) &&
       widthSizingMode == SizingMode::FitContent && availableWidth <= 0.0f) ||
      (yoga::isDefined(availableHeight) &&
       heightSizingMode == SizingMode::FitContent && availableHeight <= 0.0f) ||
      (widthSizingMode == SizingMode::StretchFit &&
       heightSizingMode == SizingMode::StretchFit)) {
=======
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
    const float ownerWidth,
    const float ownerHeight) {
  if ((!yoga::isUndefined(availableWidth) &&
       widthMeasureMode == MeasureMode::AtMost && availableWidth <= 0.0f) ||
      (!yoga::isUndefined(availableHeight) &&
       heightMeasureMode == MeasureMode::AtMost && availableHeight <= 0.0f) ||
      (widthMeasureMode == MeasureMode::Exactly &&
       heightMeasureMode == MeasureMode::Exactly)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            FlexDirection::Row,
            yoga::isUndefined(availableWidth) ||
<<<<<<< HEAD
                    (widthSizingMode == SizingMode::FitContent &&
=======
                    (widthMeasureMode == MeasureMode::AtMost &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                     availableWidth < 0.0f)
                ? 0.0f
                : availableWidth,
            ownerWidth,
            ownerWidth),
<<<<<<< HEAD
        Dimension::Width);
=======
        YGDimensionWidth);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            FlexDirection::Column,
            yoga::isUndefined(availableHeight) ||
<<<<<<< HEAD
                    (heightSizingMode == SizingMode::FitContent &&
=======
                    (heightMeasureMode == MeasureMode::AtMost &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                     availableHeight < 0.0f)
                ? 0.0f
                : availableHeight,
            ownerHeight,
            ownerWidth),
<<<<<<< HEAD
        Dimension::Height);
=======
        YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    return true;
  }

  return false;
}

static void zeroOutLayoutRecursively(yoga::Node* const node) {
  node->getLayout() = {};
<<<<<<< HEAD
  node->setLayoutDimension(0, Dimension::Width);
  node->setLayoutDimension(0, Dimension::Height);
=======
  node->setLayoutDimension(0, YGDimensionWidth);
  node->setLayoutDimension(0, YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  node->setHasNewLayout(true);

  node->cloneChildrenIfNeeded();
  for (const auto child : node->getChildren()) {
    zeroOutLayoutRecursively(child);
  }
}

static float calculateAvailableInnerDimension(
    const yoga::Node* const node,
<<<<<<< HEAD
    const Dimension dimension,
=======
    const YGDimension dimension,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float availableDim,
    const float paddingAndBorder,
    const float ownerDim) {
  float availableInnerDim = availableDim - paddingAndBorder;
  // Max dimension overrides predefined dimension value; Min dimension in turn
  // overrides both of the above
<<<<<<< HEAD
  if (yoga::isDefined(availableInnerDim)) {
    // We want to make sure our available height does not violate min and max
    // constraints
    const FloatOptional minDimensionOptional =
        node->style().minDimension(dimension).resolve(ownerDim);
=======
  if (!yoga::isUndefined(availableInnerDim)) {
    // We want to make sure our available height does not violate min and max
    // constraints
    const FloatOptional minDimensionOptional =
        yoga::resolveValue(node->getStyle().minDimension(dimension), ownerDim);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float minInnerDim = minDimensionOptional.isUndefined()
        ? 0.0f
        : minDimensionOptional.unwrap() - paddingAndBorder;

    const FloatOptional maxDimensionOptional =
<<<<<<< HEAD
        node->style().maxDimension(dimension).resolve(ownerDim);
=======
        yoga::resolveValue(node->getStyle().maxDimension(dimension), ownerDim);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    const float maxInnerDim = maxDimensionOptional.isUndefined()
        ? FLT_MAX
        : maxDimensionOptional.unwrap() - paddingAndBorder;
    availableInnerDim = yoga::maxOrDefined(
        yoga::minOrDefined(availableInnerDim, maxInnerDim), minInnerDim);
  }

  return availableInnerDim;
}

static float computeFlexBasisForChildren(
    yoga::Node* const node,
    const float availableInnerWidth,
    const float availableInnerHeight,
<<<<<<< HEAD
    SizingMode widthSizingMode,
    SizingMode heightSizingMode,
=======
    MeasureMode widthMeasureMode,
    MeasureMode heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    Direction direction,
    FlexDirection mainAxis,
    bool performLayout,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount) {
  float totalOuterFlexBasis = 0.0f;
  YGNodeRef singleFlexChild = nullptr;
  const auto& children = node->getChildren();
<<<<<<< HEAD
  SizingMode sizingModeMainDim =
      isRow(mainAxis) ? widthSizingMode : heightSizingMode;
  // If there is only one child with flexGrow + flexShrink it means we can set
  // the computedFlexBasis to 0 instead of measuring and shrinking / flexing the
  // child to exactly match the remaining space
  if (sizingModeMainDim == SizingMode::StretchFit) {
=======
  MeasureMode measureModeMainDim =
      isRow(mainAxis) ? widthMeasureMode : heightMeasureMode;
  // If there is only one child with flexGrow + flexShrink it means we can set
  // the computedFlexBasis to 0 instead of measuring and shrinking / flexing the
  // child to exactly match the remaining space
  if (measureModeMainDim == MeasureMode::Exactly) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    for (auto child : children) {
      if (child->isNodeFlexible()) {
        if (singleFlexChild != nullptr ||
            yoga::inexactEquals(child->resolveFlexGrow(), 0.0f) ||
            yoga::inexactEquals(child->resolveFlexShrink(), 0.0f)) {
          // There is already a flexible child, or this flexible child doesn't
          // have flexGrow and flexShrink, abort
          singleFlexChild = nullptr;
          break;
        } else {
          singleFlexChild = child;
        }
      }
    }
  }

  for (auto child : children) {
    child->resolveDimension();
<<<<<<< HEAD
    if (child->style().display() == Display::None) {
=======
    if (child->getStyle().display() == Display::None) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      zeroOutLayoutRecursively(child);
      child->setHasNewLayout(true);
      child->setDirty(false);
      continue;
    }
    if (performLayout) {
      // Set the initial position (relative to the owner).
      const Direction childDirection = child->resolveDirection(direction);
      const float mainDim =
          isRow(mainAxis) ? availableInnerWidth : availableInnerHeight;
      const float crossDim =
          isRow(mainAxis) ? availableInnerHeight : availableInnerWidth;
      child->setPosition(
          childDirection, mainDim, crossDim, availableInnerWidth);
    }

<<<<<<< HEAD
    if (child->style().positionType() == PositionType::Absolute) {
=======
    if (child->getStyle().positionType() == PositionType::Absolute) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      continue;
    }
    if (child == singleFlexChild) {
      child->setLayoutComputedFlexBasisGeneration(generationCount);
      child->setLayoutComputedFlexBasis(FloatOptional(0));
    } else {
      computeFlexBasisForChild(
          node,
          child,
          availableInnerWidth,
<<<<<<< HEAD
          widthSizingMode,
          availableInnerHeight,
          availableInnerWidth,
          availableInnerHeight,
          heightSizingMode,
=======
          widthMeasureMode,
          availableInnerHeight,
          availableInnerWidth,
          availableInnerHeight,
          heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          direction,
          layoutMarkerData,
          depth,
          generationCount);
    }

    totalOuterFlexBasis +=
<<<<<<< HEAD
        (child->getLayout().computedFlexBasis.unwrap() +
         child->style().computeMarginForAxis(mainAxis, availableInnerWidth));
=======
        (child->getLayout().computedFlexBasis +
         child->getMarginForAxis(mainAxis, availableInnerWidth))
            .unwrap();
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }

  return totalOuterFlexBasis;
}

// It distributes the free space to the flexible items and ensures that the size
// of the flex items abide the min and max constraints. At the end of this
// function the child nodes would have proper size. Prior using this function
// please ensure that distributeFreeSpaceFirstPass is called.
static float distributeFreeSpaceSecondPass(
    FlexLine& flexLine,
    yoga::Node* const node,
    const FlexDirection mainAxis,
    const FlexDirection crossAxis,
<<<<<<< HEAD
    const Direction direction,
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float mainAxisownerSize,
    const float availableInnerMainDim,
    const float availableInnerCrossDim,
    const float availableInnerWidth,
    const float availableInnerHeight,
    const bool mainAxisOverflows,
<<<<<<< HEAD
    const SizingMode sizingModeCrossDim,
=======
    const MeasureMode measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const bool performLayout,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount) {
  float childFlexBasis = 0;
  float flexShrinkScaledFactor = 0;
  float flexGrowFactor = 0;
  float deltaFreeSpace = 0;
  const bool isMainAxisRow = isRow(mainAxis);
<<<<<<< HEAD
  const bool isNodeFlexWrap = node->style().flexWrap() != Wrap::NoWrap;
=======
  const bool isNodeFlexWrap = node->getStyle().flexWrap() != Wrap::NoWrap;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  for (auto currentLineChild : flexLine.itemsInFlow) {
    childFlexBasis = boundAxisWithinMinAndMax(
                         currentLineChild,
                         mainAxis,
                         currentLineChild->getLayout().computedFlexBasis,
                         mainAxisownerSize)
                         .unwrap();
    float updatedMainSize = childFlexBasis;

<<<<<<< HEAD
    if (yoga::isDefined(flexLine.layout.remainingFreeSpace) &&
=======
    if (!yoga::isUndefined(flexLine.layout.remainingFreeSpace) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        flexLine.layout.remainingFreeSpace < 0) {
      flexShrinkScaledFactor =
          -currentLineChild->resolveFlexShrink() * childFlexBasis;
      // Is this child able to shrink?
      if (flexShrinkScaledFactor != 0) {
        float childSize;

<<<<<<< HEAD
        if (yoga::isDefined(flexLine.layout.totalFlexShrinkScaledFactors) &&
=======
        if (!yoga::isUndefined(flexLine.layout.totalFlexShrinkScaledFactors) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
            flexLine.layout.totalFlexShrinkScaledFactors == 0) {
          childSize = childFlexBasis + flexShrinkScaledFactor;
        } else {
          childSize = childFlexBasis +
              (flexLine.layout.remainingFreeSpace /
               flexLine.layout.totalFlexShrinkScaledFactors) *
                  flexShrinkScaledFactor;
        }

        updatedMainSize = boundAxis(
            currentLineChild,
            mainAxis,
            childSize,
            availableInnerMainDim,
            availableInnerWidth);
      }
    } else if (
<<<<<<< HEAD
        yoga::isDefined(flexLine.layout.remainingFreeSpace) &&
=======
        !yoga::isUndefined(flexLine.layout.remainingFreeSpace) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        flexLine.layout.remainingFreeSpace > 0) {
      flexGrowFactor = currentLineChild->resolveFlexGrow();

      // Is this child able to grow?
      if (!std::isnan(flexGrowFactor) && flexGrowFactor != 0) {
        updatedMainSize = boundAxis(
            currentLineChild,
            mainAxis,
            childFlexBasis +
                flexLine.layout.remainingFreeSpace /
                    flexLine.layout.totalFlexGrowFactors * flexGrowFactor,
            availableInnerMainDim,
            availableInnerWidth);
      }
    }

    deltaFreeSpace += updatedMainSize - childFlexBasis;

<<<<<<< HEAD
    const float marginMain = currentLineChild->style().computeMarginForAxis(
        mainAxis, availableInnerWidth);
    const float marginCross = currentLineChild->style().computeMarginForAxis(
        crossAxis, availableInnerWidth);

    float childCrossSize;
    float childMainSize = updatedMainSize + marginMain;
    SizingMode childCrossSizingMode;
    SizingMode childMainSizingMode = SizingMode::StretchFit;

    const auto& childStyle = currentLineChild->style();
    if (childStyle.aspectRatio().isDefined()) {
      childCrossSize = isMainAxisRow
          ? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()
          : (childMainSize - marginMain) * childStyle.aspectRatio().unwrap();
      childCrossSizingMode = SizingMode::StretchFit;
=======
    const float marginMain =
        currentLineChild->getMarginForAxis(mainAxis, availableInnerWidth)
            .unwrap();
    const float marginCross =
        currentLineChild->getMarginForAxis(crossAxis, availableInnerWidth)
            .unwrap();

    float childCrossSize;
    float childMainSize = updatedMainSize + marginMain;
    MeasureMode childCrossMeasureMode;
    MeasureMode childMainMeasureMode = MeasureMode::Exactly;

    const auto& childStyle = currentLineChild->getStyle();
    if (!childStyle.aspectRatio().isUndefined()) {
      childCrossSize = isMainAxisRow
          ? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()
          : (childMainSize - marginMain) * childStyle.aspectRatio().unwrap();
      childCrossMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

      childCrossSize += marginCross;
    } else if (
        !std::isnan(availableInnerCrossDim) &&
<<<<<<< HEAD
        !currentLineChild->hasDefiniteLength(
            dimension(crossAxis), availableInnerCrossDim) &&
        sizingModeCrossDim == SizingMode::StretchFit &&
        !(isNodeFlexWrap && mainAxisOverflows) &&
        resolveChildAlignment(node, currentLineChild) == Align::Stretch &&
        !currentLineChild->style().flexStartMarginIsAuto(
            crossAxis, direction) &&
        !currentLineChild->style().flexEndMarginIsAuto(crossAxis, direction)) {
      childCrossSize = availableInnerCrossDim;
      childCrossSizingMode = SizingMode::StretchFit;
    } else if (!currentLineChild->hasDefiniteLength(
                   dimension(crossAxis), availableInnerCrossDim)) {
      childCrossSize = availableInnerCrossDim;
      childCrossSizingMode = yoga::isUndefined(childCrossSize)
          ? SizingMode::MaxContent
          : SizingMode::FitContent;
    } else {
      childCrossSize =
          currentLineChild->getResolvedDimension(dimension(crossAxis))
              .resolve(availableInnerCrossDim)
              .unwrap() +
          marginCross;
      const bool isLoosePercentageMeasurement =
          currentLineChild->getResolvedDimension(dimension(crossAxis)).unit() ==
              Unit::Percent &&
          sizingModeCrossDim != SizingMode::StretchFit;
      childCrossSizingMode =
          yoga::isUndefined(childCrossSize) || isLoosePercentageMeasurement
          ? SizingMode::MaxContent
          : SizingMode::StretchFit;
=======
        !styleDefinesDimension(
            currentLineChild, crossAxis, availableInnerCrossDim) &&
        measureModeCrossDim == MeasureMode::Exactly &&
        !(isNodeFlexWrap && mainAxisOverflows) &&
        resolveChildAlignment(node, currentLineChild) == Align::Stretch &&
        currentLineChild->marginLeadingValue(crossAxis).unit != YGUnitAuto &&
        currentLineChild->marginTrailingValue(crossAxis).unit != YGUnitAuto) {
      childCrossSize = availableInnerCrossDim;
      childCrossMeasureMode = MeasureMode::Exactly;
    } else if (!styleDefinesDimension(
                   currentLineChild, crossAxis, availableInnerCrossDim)) {
      childCrossSize = availableInnerCrossDim;
      childCrossMeasureMode = yoga::isUndefined(childCrossSize)
          ? MeasureMode::Undefined
          : MeasureMode::AtMost;
    } else {
      childCrossSize =
          yoga::resolveValue(
              currentLineChild->getResolvedDimension(dimension(crossAxis)),
              availableInnerCrossDim)
              .unwrap() +
          marginCross;
      const bool isLoosePercentageMeasurement =
          currentLineChild->getResolvedDimension(dimension(crossAxis)).unit ==
              YGUnitPercent &&
          measureModeCrossDim != MeasureMode::Exactly;
      childCrossMeasureMode =
          yoga::isUndefined(childCrossSize) || isLoosePercentageMeasurement
          ? MeasureMode::Undefined
          : MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    }

    constrainMaxSizeForMode(
        currentLineChild,
        mainAxis,
        availableInnerMainDim,
        availableInnerWidth,
<<<<<<< HEAD
        &childMainSizingMode,
=======
        &childMainMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        &childMainSize);
    constrainMaxSizeForMode(
        currentLineChild,
        crossAxis,
        availableInnerCrossDim,
        availableInnerWidth,
<<<<<<< HEAD
        &childCrossSizingMode,
        &childCrossSize);

    const bool requiresStretchLayout =
        !currentLineChild->hasDefiniteLength(
            dimension(crossAxis), availableInnerCrossDim) &&
        resolveChildAlignment(node, currentLineChild) == Align::Stretch &&
        !currentLineChild->style().flexStartMarginIsAuto(
            crossAxis, direction) &&
        !currentLineChild->style().flexEndMarginIsAuto(crossAxis, direction);
=======
        &childCrossMeasureMode,
        &childCrossSize);

    const bool requiresStretchLayout =
        !styleDefinesDimension(
            currentLineChild, crossAxis, availableInnerCrossDim) &&
        resolveChildAlignment(node, currentLineChild) == Align::Stretch &&
        currentLineChild->marginLeadingValue(crossAxis).unit != YGUnitAuto &&
        currentLineChild->marginTrailingValue(crossAxis).unit != YGUnitAuto;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    const float childWidth = isMainAxisRow ? childMainSize : childCrossSize;
    const float childHeight = !isMainAxisRow ? childMainSize : childCrossSize;

<<<<<<< HEAD
    const SizingMode childWidthSizingMode =
        isMainAxisRow ? childMainSizingMode : childCrossSizingMode;
    const SizingMode childHeightSizingMode =
        !isMainAxisRow ? childMainSizingMode : childCrossSizingMode;
=======
    const MeasureMode childWidthMeasureMode =
        isMainAxisRow ? childMainMeasureMode : childCrossMeasureMode;
    const MeasureMode childHeightMeasureMode =
        !isMainAxisRow ? childMainMeasureMode : childCrossMeasureMode;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    const bool isLayoutPass = performLayout && !requiresStretchLayout;
    // Recursively call the layout algorithm for this child with the updated
    // main size.
    calculateLayoutInternal(
        currentLineChild,
        childWidth,
        childHeight,
        node->getLayout().direction(),
<<<<<<< HEAD
        childWidthSizingMode,
        childHeightSizingMode,
=======
        childWidthMeasureMode,
        childHeightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        availableInnerWidth,
        availableInnerHeight,
        isLayoutPass,
        isLayoutPass ? LayoutPassReason::kFlexLayout
                     : LayoutPassReason::kFlexMeasure,
        layoutMarkerData,
        depth,
        generationCount);
    node->setLayoutHadOverflow(
        node->getLayout().hadOverflow() ||
        currentLineChild->getLayout().hadOverflow());
  }
  return deltaFreeSpace;
}

// It distributes the free space to the flexible items.For those flexible items
// whose min and max constraints are triggered, those flex item's clamped size
// is removed from the remaingfreespace.
static void distributeFreeSpaceFirstPass(
    FlexLine& flexLine,
    const FlexDirection mainAxis,
    const float mainAxisownerSize,
    const float availableInnerMainDim,
    const float availableInnerWidth) {
  float flexShrinkScaledFactor = 0;
  float flexGrowFactor = 0;
  float baseMainSize = 0;
  float boundMainSize = 0;
  float deltaFreeSpace = 0;

  for (auto currentLineChild : flexLine.itemsInFlow) {
    float childFlexBasis = boundAxisWithinMinAndMax(
                               currentLineChild,
                               mainAxis,
                               currentLineChild->getLayout().computedFlexBasis,
                               mainAxisownerSize)
                               .unwrap();

    if (flexLine.layout.remainingFreeSpace < 0) {
      flexShrinkScaledFactor =
          -currentLineChild->resolveFlexShrink() * childFlexBasis;

      // Is this child able to shrink?
<<<<<<< HEAD
      if (yoga::isDefined(flexShrinkScaledFactor) &&
=======
      if (!yoga::isUndefined(flexShrinkScaledFactor) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          flexShrinkScaledFactor != 0) {
        baseMainSize = childFlexBasis +
            flexLine.layout.remainingFreeSpace /
                flexLine.layout.totalFlexShrinkScaledFactors *
                flexShrinkScaledFactor;
        boundMainSize = boundAxis(
            currentLineChild,
            mainAxis,
            baseMainSize,
            availableInnerMainDim,
            availableInnerWidth);
<<<<<<< HEAD
        if (yoga::isDefined(baseMainSize) && yoga::isDefined(boundMainSize) &&
=======
        if (!yoga::isUndefined(baseMainSize) &&
            !yoga::isUndefined(boundMainSize) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
            baseMainSize != boundMainSize) {
          // By excluding this item's size and flex factor from remaining, this
          // item's min/max constraints should also trigger in the second pass
          // resulting in the item's size calculation being identical in the
          // first and second passes.
          deltaFreeSpace += boundMainSize - childFlexBasis;
          flexLine.layout.totalFlexShrinkScaledFactors -=
              (-currentLineChild->resolveFlexShrink() *
               currentLineChild->getLayout().computedFlexBasis.unwrap());
        }
      }
    } else if (
<<<<<<< HEAD
        yoga::isDefined(flexLine.layout.remainingFreeSpace) &&
=======
        !yoga::isUndefined(flexLine.layout.remainingFreeSpace) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        flexLine.layout.remainingFreeSpace > 0) {
      flexGrowFactor = currentLineChild->resolveFlexGrow();

      // Is this child able to grow?
<<<<<<< HEAD
      if (yoga::isDefined(flexGrowFactor) && flexGrowFactor != 0) {
=======
      if (!yoga::isUndefined(flexGrowFactor) && flexGrowFactor != 0) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        baseMainSize = childFlexBasis +
            flexLine.layout.remainingFreeSpace /
                flexLine.layout.totalFlexGrowFactors * flexGrowFactor;
        boundMainSize = boundAxis(
            currentLineChild,
            mainAxis,
            baseMainSize,
            availableInnerMainDim,
            availableInnerWidth);

<<<<<<< HEAD
        if (yoga::isDefined(baseMainSize) && yoga::isDefined(boundMainSize) &&
=======
        if (!yoga::isUndefined(baseMainSize) &&
            !yoga::isUndefined(boundMainSize) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
            baseMainSize != boundMainSize) {
          // By excluding this item's size and flex factor from remaining, this
          // item's min/max constraints should also trigger in the second pass
          // resulting in the item's size calculation being identical in the
          // first and second passes.
          deltaFreeSpace += boundMainSize - childFlexBasis;
          flexLine.layout.totalFlexGrowFactors -= flexGrowFactor;
        }
      }
    }
  }
  flexLine.layout.remainingFreeSpace -= deltaFreeSpace;
}

// Do two passes over the flex items to figure out how to distribute the
// remaining space.
//
// The first pass finds the items whose min/max constraints trigger, freezes
// them at those sizes, and excludes those sizes from the remaining space.
//
// The second pass sets the size of each flexible item. It distributes the
// remaining space amongst the items whose min/max constraints didn't trigger in
// the first pass. For the other items, it sets their sizes by forcing their
// min/max constraints to trigger again.
//
// This two pass approach for resolving min/max constraints deviates from the
// spec. The spec
// (https://www.w3.org/TR/CSS-flexbox-1/#resolve-flexible-lengths) describes a
// process that needs to be repeated a variable number of times. The algorithm
// implemented here won't handle all cases but it was simpler to implement and
// it mitigates performance concerns because we know exactly how many passes
// it'll do.
//
// At the end of this function the child nodes would have the proper size
// assigned to them.
//
static void resolveFlexibleLength(
    yoga::Node* const node,
    FlexLine& flexLine,
    const FlexDirection mainAxis,
    const FlexDirection crossAxis,
<<<<<<< HEAD
    const Direction direction,
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float mainAxisownerSize,
    const float availableInnerMainDim,
    const float availableInnerCrossDim,
    const float availableInnerWidth,
    const float availableInnerHeight,
    const bool mainAxisOverflows,
<<<<<<< HEAD
    const SizingMode sizingModeCrossDim,
=======
    const MeasureMode measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const bool performLayout,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount) {
  const float originalFreeSpace = flexLine.layout.remainingFreeSpace;
  // First pass: detect the flex items whose min/max constraints trigger
  distributeFreeSpaceFirstPass(
      flexLine,
      mainAxis,
      mainAxisownerSize,
      availableInnerMainDim,
      availableInnerWidth);

  // Second pass: resolve the sizes of the flexible items
  const float distributedFreeSpace = distributeFreeSpaceSecondPass(
      flexLine,
      node,
      mainAxis,
      crossAxis,
<<<<<<< HEAD
      direction,
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      mainAxisownerSize,
      availableInnerMainDim,
      availableInnerCrossDim,
      availableInnerWidth,
      availableInnerHeight,
      mainAxisOverflows,
<<<<<<< HEAD
      sizingModeCrossDim,
=======
      measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      performLayout,
      layoutMarkerData,
      depth,
      generationCount);

  flexLine.layout.remainingFreeSpace = originalFreeSpace - distributedFreeSpace;
}

static void justifyMainAxis(
    yoga::Node* const node,
    FlexLine& flexLine,
    const size_t startOfLineIndex,
    const FlexDirection mainAxis,
    const FlexDirection crossAxis,
<<<<<<< HEAD
    const Direction direction,
    const SizingMode sizingModeMainDim,
    const SizingMode sizingModeCrossDim,
=======
    const MeasureMode measureModeMainDim,
    const MeasureMode measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float mainAxisownerSize,
    const float ownerWidth,
    const float availableInnerMainDim,
    const float availableInnerCrossDim,
    const float availableInnerWidth,
    const bool performLayout) {
<<<<<<< HEAD
  const auto& style = node->style();

  const float leadingPaddingAndBorderMain =
      node->style().computeFlexStartPaddingAndBorder(
          mainAxis, direction, ownerWidth);
  const float trailingPaddingAndBorderMain =
      node->style().computeFlexEndPaddingAndBorder(
          mainAxis, direction, ownerWidth);

  const float gap = node->style().computeGapForAxis(mainAxis);
  // If we are using "at most" rules in the main axis, make sure that
  // remainingFreeSpace is 0 when min main dimension is not given
  if (sizingModeMainDim == SizingMode::FitContent &&
      flexLine.layout.remainingFreeSpace > 0) {
    if (style.minDimension(dimension(mainAxis)).isDefined() &&
        style.minDimension(dimension(mainAxis))
            .resolve(mainAxisownerSize)
            .isDefined()) {
=======
  const auto& style = node->getStyle();
  const float leadingPaddingAndBorderMain =
      node->getLeadingPaddingAndBorder(mainAxis, ownerWidth).unwrap();
  const float trailingPaddingAndBorderMain =
      node->getTrailingPaddingAndBorder(mainAxis, ownerWidth).unwrap();
  const float gap = node->getGapForAxis(mainAxis, ownerWidth).unwrap();
  // If we are using "at most" rules in the main axis, make sure that
  // remainingFreeSpace is 0 when min main dimension is not given
  if (measureModeMainDim == MeasureMode::AtMost &&
      flexLine.layout.remainingFreeSpace > 0) {
    if (!style.minDimension(dimension(mainAxis)).isUndefined() &&
        !yoga::resolveValue(
             style.minDimension(dimension(mainAxis)), mainAxisownerSize)
             .isUndefined()) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      // This condition makes sure that if the size of main dimension(after
      // considering child nodes main dim, leading and trailing padding etc)
      // falls below min dimension, then the remainingFreeSpace is reassigned
      // considering the min dimension

      // `minAvailableMainDim` denotes minimum available space in which child
      // can be laid out, it will exclude space consumed by padding and border.
<<<<<<< HEAD
      const float minAvailableMainDim = style.minDimension(dimension(mainAxis))
                                            .resolve(mainAxisownerSize)
                                            .unwrap() -
=======
      const float minAvailableMainDim =
          yoga::resolveValue(
              style.minDimension(dimension(mainAxis)), mainAxisownerSize)
              .unwrap() -
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          leadingPaddingAndBorderMain - trailingPaddingAndBorderMain;
      const float occupiedSpaceByChildNodes =
          availableInnerMainDim - flexLine.layout.remainingFreeSpace;
      flexLine.layout.remainingFreeSpace = yoga::maxOrDefined(
<<<<<<< HEAD
          0.0f, minAvailableMainDim - occupiedSpaceByChildNodes);
=======
          0, minAvailableMainDim - occupiedSpaceByChildNodes);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    } else {
      flexLine.layout.remainingFreeSpace = 0;
    }
  }

  int numberOfAutoMarginsOnCurrentLine = 0;
  for (size_t i = startOfLineIndex; i < flexLine.endOfLineIndex; i++) {
    auto child = node->getChild(i);
<<<<<<< HEAD
    if (child->style().positionType() != PositionType::Absolute) {
      if (child->style().flexStartMarginIsAuto(mainAxis, direction)) {
        numberOfAutoMarginsOnCurrentLine++;
      }
      if (child->style().flexEndMarginIsAuto(mainAxis, direction)) {
=======
    if (child->getStyle().positionType() != PositionType::Absolute) {
      if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
        numberOfAutoMarginsOnCurrentLine++;
      }
      if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        numberOfAutoMarginsOnCurrentLine++;
      }
    }
  }

  // In order to position the elements in the main axis, we have two controls.
  // The space between the beginning and the first element and the space between
  // each two elements.
  float leadingMainDim = 0;
  float betweenMainDim = gap;
<<<<<<< HEAD
  const Justify justifyContent = node->style().justifyContent();
=======
  const Justify justifyContent = node->getStyle().justifyContent();
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  if (numberOfAutoMarginsOnCurrentLine == 0) {
    switch (justifyContent) {
      case Justify::Center:
        leadingMainDim = flexLine.layout.remainingFreeSpace / 2;
        break;
      case Justify::FlexEnd:
        leadingMainDim = flexLine.layout.remainingFreeSpace;
        break;
      case Justify::SpaceBetween:
        if (flexLine.itemsInFlow.size() > 1) {
          betweenMainDim +=
<<<<<<< HEAD
              yoga::maxOrDefined(flexLine.layout.remainingFreeSpace, 0.0f) /
=======
              yoga::maxOrDefined(flexLine.layout.remainingFreeSpace, 0) /
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
              static_cast<float>(flexLine.itemsInFlow.size() - 1);
        }
        break;
      case Justify::SpaceEvenly:
        // Space is distributed evenly across all elements
        leadingMainDim = flexLine.layout.remainingFreeSpace /
            static_cast<float>(flexLine.itemsInFlow.size() + 1);
        betweenMainDim += leadingMainDim;
        break;
      case Justify::SpaceAround:
        // Space on the edges is half of the space between elements
        leadingMainDim = 0.5f * flexLine.layout.remainingFreeSpace /
            static_cast<float>(flexLine.itemsInFlow.size());
        betweenMainDim += leadingMainDim * 2;
        break;
      case Justify::FlexStart:
        break;
    }
  }

  flexLine.layout.mainDim = leadingPaddingAndBorderMain + leadingMainDim;
  flexLine.layout.crossDim = 0;

  float maxAscentForCurrentLine = 0;
  float maxDescentForCurrentLine = 0;
  bool isNodeBaselineLayout = isBaselineLayout(node);
  for (size_t i = startOfLineIndex; i < flexLine.endOfLineIndex; i++) {
    const auto child = node->getChild(i);
<<<<<<< HEAD
    const Style& childStyle = child->style();
=======
    const Style& childStyle = child->getStyle();
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const LayoutResults& childLayout = child->getLayout();
    if (childStyle.display() == Display::None) {
      continue;
    }
    if (childStyle.positionType() == PositionType::Absolute &&
<<<<<<< HEAD
        child->style().isFlexStartPositionDefined(mainAxis, direction)) {
=======
        child->isLeadingPositionDefined(mainAxis)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      if (performLayout) {
        // In case the child is position absolute and has left/top being
        // defined, we override the position to whatever the user said (and
        // margin/border).
        child->setLayoutPosition(
<<<<<<< HEAD
            child->style().computeFlexStartPosition(
                mainAxis, direction, availableInnerMainDim) +
                node->style().computeFlexStartBorder(mainAxis, direction) +
                child->style().computeFlexStartMargin(
                    mainAxis, direction, availableInnerWidth),
            flexStartEdge(mainAxis));
=======
            child->getLeadingPosition(mainAxis, availableInnerMainDim)
                    .unwrap() +
                node->getLeadingBorder(mainAxis) +
                child->getLeadingMargin(mainAxis, availableInnerWidth).unwrap(),
            leadingEdge(mainAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    } else {
      // Now that we placed the element, we need to update the variables.
      // We need to do that only for relative elements. Absolute elements do not
      // take part in that phase.
      if (childStyle.positionType() != PositionType::Absolute) {
<<<<<<< HEAD
        if (child->style().flexStartMarginIsAuto(mainAxis, direction)) {
=======
        if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          flexLine.layout.mainDim += flexLine.layout.remainingFreeSpace /
              static_cast<float>(numberOfAutoMarginsOnCurrentLine);
        }

        if (performLayout) {
          child->setLayoutPosition(
<<<<<<< HEAD
              childLayout.position(flexStartEdge(mainAxis)) +
                  flexLine.layout.mainDim,
              flexStartEdge(mainAxis));
=======
              childLayout.position[leadingEdge(mainAxis)] +
                  flexLine.layout.mainDim,
              leadingEdge(mainAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        }

        if (child != flexLine.itemsInFlow.back()) {
          flexLine.layout.mainDim += betweenMainDim;
        }

<<<<<<< HEAD
        if (child->style().flexEndMarginIsAuto(mainAxis, direction)) {
=======
        if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          flexLine.layout.mainDim += flexLine.layout.remainingFreeSpace /
              static_cast<float>(numberOfAutoMarginsOnCurrentLine);
        }
        bool canSkipFlex =
<<<<<<< HEAD
            !performLayout && sizingModeCrossDim == SizingMode::StretchFit;
=======
            !performLayout && measureModeCrossDim == MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        if (canSkipFlex) {
          // If we skipped the flex step, then we can't rely on the measuredDims
          // because they weren't computed. This means we can't call
          // dimensionWithMargin.
<<<<<<< HEAD
          flexLine.layout.mainDim += child->style().computeMarginForAxis(
                                         mainAxis, availableInnerWidth) +
=======
          flexLine.layout.mainDim +=
              child->getMarginForAxis(mainAxis, availableInnerWidth).unwrap() +
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
              childLayout.computedFlexBasis.unwrap();
          flexLine.layout.crossDim = availableInnerCrossDim;
        } else {
          // The main dimension is the sum of all the elements dimension plus
          // the spacing.
          flexLine.layout.mainDim +=
<<<<<<< HEAD
              child->dimensionWithMargin(mainAxis, availableInnerWidth);
=======
              dimensionWithMargin(child, mainAxis, availableInnerWidth);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

          if (isNodeBaselineLayout) {
            // If the child is baseline aligned then the cross dimension is
            // calculated by adding maxAscent and maxDescent from the baseline.
            const float ascent = calculateBaseline(child) +
<<<<<<< HEAD
                child->style().computeFlexStartMargin(
                    FlexDirection::Column, direction, availableInnerWidth);
            const float descent =
                child->getLayout().measuredDimension(Dimension::Height) +
                child->style().computeMarginForAxis(
                    FlexDirection::Column, availableInnerWidth) -
=======
                child
                    ->getLeadingMargin(
                        FlexDirection::Column, availableInnerWidth)
                    .unwrap();
            const float descent =
                child->getLayout().measuredDimension(YGDimensionHeight) +
                child
                    ->getMarginForAxis(
                        FlexDirection::Column, availableInnerWidth)
                    .unwrap() -
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                ascent;

            maxAscentForCurrentLine =
                yoga::maxOrDefined(maxAscentForCurrentLine, ascent);
            maxDescentForCurrentLine =
                yoga::maxOrDefined(maxDescentForCurrentLine, descent);
          } else {
            // The cross dimension is the max of the elements dimension since
            // there can only be one element in that cross dimension in the case
            // when the items are not baseline aligned
            flexLine.layout.crossDim = yoga::maxOrDefined(
                flexLine.layout.crossDim,
<<<<<<< HEAD
                child->dimensionWithMargin(crossAxis, availableInnerWidth));
=======
                dimensionWithMargin(child, crossAxis, availableInnerWidth));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          }
        }
      } else if (performLayout) {
        child->setLayoutPosition(
<<<<<<< HEAD
            childLayout.position(flexStartEdge(mainAxis)) +
                node->style().computeFlexStartBorder(mainAxis, direction) +
                leadingMainDim,
            flexStartEdge(mainAxis));
=======
            childLayout.position[leadingEdge(mainAxis)] +
                node->getLeadingBorder(mainAxis) + leadingMainDim,
            leadingEdge(mainAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    }
  }
  flexLine.layout.mainDim += trailingPaddingAndBorderMain;

  if (isNodeBaselineLayout) {
    flexLine.layout.crossDim =
        maxAscentForCurrentLine + maxDescentForCurrentLine;
  }
}

//
// This is the main routine that implements a subset of the flexbox layout
// algorithm described in the W3C CSS documentation:
// https://www.w3.org/TR/CSS3-flexbox/.
//
// Limitations of this algorithm, compared to the full standard:
//  * Display property is always assumed to be 'flex' except for Text nodes,
//    which are assumed to be 'inline-flex'.
//  * The 'zIndex' property (or any form of z ordering) is not supported. Nodes
//    are stacked in document order.
//  * The 'order' property is not supported. The order of flex items is always
//    defined by document order.
//  * The 'visibility' property is always assumed to be 'visible'. Values of
//    'collapse' and 'hidden' are not supported.
//  * There is no support for forced breaks.
//  * It does not support vertical inline directions (top-to-bottom or
//    bottom-to-top text).
//
// Deviations from standard:
//  * Section 4.5 of the spec indicates that all flex items have a default
//    minimum main size. For text blocks, for example, this is the width of the
//    widest word. Calculating the minimum width is expensive, so we forego it
//    and assume a default minimum main size of 0.
//  * Min/Max sizes in the main axis are not honored when resolving flexible
//    lengths.
//  * The spec indicates that the default value for 'flexDirection' is 'row',
//    but the algorithm below assumes a default of 'column'.
//
// Input parameters:
//    - node: current node to be sized and laid out
//    - availableWidth & availableHeight: available size to be used for sizing
//      the node or YGUndefined if the size is not available; interpretation
//      depends on layout flags
//    - ownerDirection: the inline (text) direction within the owner
//      (left-to-right or right-to-left)
<<<<<<< HEAD
//    - widthSizingMode: indicates the sizing rules for the width (see below
//      for explanation)
//    - heightSizingMode: indicates the sizing rules for the height (see below
=======
//    - widthMeasureMode: indicates the sizing rules for the width (see below
//      for explanation)
//    - heightMeasureMode: indicates the sizing rules for the height (see below
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
//      for explanation)
//    - performLayout: specifies whether the caller is interested in just the
//      dimensions of the node or it requires the entire node and its subtree to
//      be laid out (with final positions)
//
// Details:
//    This routine is called recursively to lay out subtrees of flexbox
//    elements. It uses the information in node.style, which is treated as a
//    read-only input. It is responsible for setting the layout.direction and
//    layout.measuredDimensions fields for the input node as well as the
//    layout.position and layout.lineIndex fields for its child nodes. The
//    layout.measuredDimensions field includes any border or padding for the
//    node but does not include margins.
//
<<<<<<< HEAD
//    When calling calculateLayoutImpl and calculateLayoutInternal, if the
//    caller passes an available size of undefined then it must also pass a
//    measure mode of SizingMode::MaxContent in that dimension.
=======
//    The spec describes four different layout modes: "fill available", "max
//    content", "min content", and "fit content". Of these, we don't use "min
//    content" because we don't support default minimum main sizes (see above
//    for details). Each of our measure modes maps to a layout mode from the
//    spec (https://www.w3.org/TR/CSS3-sizing/#terms):
//      - MeasureMode::Undefined: max content
//      - MeasureMode::Exactly: fill available
//      - MeasureMode::AtMost: fit content
//
//    When calling calculateLayoutImpl and calculateLayoutInternal, if the
//    caller passes an available size of undefined then it must also pass a
//    measure mode of MeasureMode::Undefined in that dimension.
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
//
static void calculateLayoutImpl(
    yoga::Node* const node,
    const float availableWidth,
    const float availableHeight,
    const Direction ownerDirection,
<<<<<<< HEAD
    const SizingMode widthSizingMode,
    const SizingMode heightSizingMode,
=======
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float ownerWidth,
    const float ownerHeight,
    const bool performLayout,
    LayoutData& layoutMarkerData,
    const uint32_t depth,
    const uint32_t generationCount,
    const LayoutPassReason reason) {
  yoga::assertFatalWithNode(
      node,
      yoga::isUndefined(availableWidth)
<<<<<<< HEAD
          ? widthSizingMode == SizingMode::MaxContent
          : true,
      "availableWidth is indefinite so widthSizingMode must be "
      "SizingMode::MaxContent");
  yoga::assertFatalWithNode(
      node,
      yoga::isUndefined(availableHeight)
          ? heightSizingMode == SizingMode::MaxContent
          : true,
      "availableHeight is indefinite so heightSizingMode must be "
      "SizingMode::MaxContent");
=======
          ? widthMeasureMode == MeasureMode::Undefined
          : true,
      "availableWidth is indefinite so widthMeasureMode must be "
      "MeasureMode::Undefined");
  yoga::assertFatalWithNode(
      node,
      yoga::isUndefined(availableHeight)
          ? heightMeasureMode == MeasureMode::Undefined
          : true,
      "availableHeight is indefinite so heightMeasureMode must be "
      "MeasureMode::Undefined");
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  (performLayout ? layoutMarkerData.layouts : layoutMarkerData.measures) += 1;

  // Set the resolved resolution in the node's layout.
  const Direction direction = node->resolveDirection(ownerDirection);
  node->setLayoutDirection(direction);

  const FlexDirection flexRowDirection =
      resolveDirection(FlexDirection::Row, direction);
  const FlexDirection flexColumnDirection =
      resolveDirection(FlexDirection::Column, direction);

<<<<<<< HEAD
  const auto startEdge =
      direction == Direction::LTR ? PhysicalEdge::Left : PhysicalEdge::Right;
  const auto endEdge =
      direction == Direction::LTR ? PhysicalEdge::Right : PhysicalEdge::Left;

  const float marginRowLeading = node->style().computeInlineStartMargin(
      flexRowDirection, direction, ownerWidth);
  node->setLayoutMargin(marginRowLeading, startEdge);
  const float marginRowTrailing = node->style().computeInlineEndMargin(
      flexRowDirection, direction, ownerWidth);
  node->setLayoutMargin(marginRowTrailing, endEdge);
  const float marginColumnLeading = node->style().computeInlineStartMargin(
      flexColumnDirection, direction, ownerWidth);
  node->setLayoutMargin(marginColumnLeading, PhysicalEdge::Top);
  const float marginColumnTrailing = node->style().computeInlineEndMargin(
      flexColumnDirection, direction, ownerWidth);
  node->setLayoutMargin(marginColumnTrailing, PhysicalEdge::Bottom);
=======
  const YGEdge startEdge =
      direction == Direction::LTR ? YGEdgeLeft : YGEdgeRight;
  const YGEdge endEdge = direction == Direction::LTR ? YGEdgeRight : YGEdgeLeft;

  const float marginRowLeading =
      node->getLeadingMargin(flexRowDirection, ownerWidth).unwrap();
  node->setLayoutMargin(marginRowLeading, startEdge);
  const float marginRowTrailing =
      node->getTrailingMargin(flexRowDirection, ownerWidth).unwrap();
  node->setLayoutMargin(marginRowTrailing, endEdge);
  const float marginColumnLeading =
      node->getLeadingMargin(flexColumnDirection, ownerWidth).unwrap();
  node->setLayoutMargin(marginColumnLeading, YGEdgeTop);
  const float marginColumnTrailing =
      node->getTrailingMargin(flexColumnDirection, ownerWidth).unwrap();
  node->setLayoutMargin(marginColumnTrailing, YGEdgeBottom);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  const float marginAxisRow = marginRowLeading + marginRowTrailing;
  const float marginAxisColumn = marginColumnLeading + marginColumnTrailing;

<<<<<<< HEAD
  node->setLayoutBorder(
      node->style().computeInlineStartBorder(flexRowDirection, direction),
      startEdge);
  node->setLayoutBorder(
      node->style().computeInlineEndBorder(flexRowDirection, direction),
      endEdge);
  node->setLayoutBorder(
      node->style().computeInlineStartBorder(flexColumnDirection, direction),
      PhysicalEdge::Top);
  node->setLayoutBorder(
      node->style().computeInlineEndBorder(flexColumnDirection, direction),
      PhysicalEdge::Bottom);

  node->setLayoutPadding(
      node->style().computeInlineStartPadding(
          flexRowDirection, direction, ownerWidth),
      startEdge);
  node->setLayoutPadding(
      node->style().computeInlineEndPadding(
          flexRowDirection, direction, ownerWidth),
      endEdge);
  node->setLayoutPadding(
      node->style().computeInlineStartPadding(
          flexColumnDirection, direction, ownerWidth),
      PhysicalEdge::Top);
  node->setLayoutPadding(
      node->style().computeInlineEndPadding(
          flexColumnDirection, direction, ownerWidth),
      PhysicalEdge::Bottom);
=======
  node->setLayoutBorder(node->getLeadingBorder(flexRowDirection), startEdge);
  node->setLayoutBorder(node->getTrailingBorder(flexRowDirection), endEdge);
  node->setLayoutBorder(node->getLeadingBorder(flexColumnDirection), YGEdgeTop);
  node->setLayoutBorder(
      node->getTrailingBorder(flexColumnDirection), YGEdgeBottom);

  node->setLayoutPadding(
      node->getLeadingPadding(flexRowDirection, ownerWidth).unwrap(),
      startEdge);
  node->setLayoutPadding(
      node->getTrailingPadding(flexRowDirection, ownerWidth).unwrap(), endEdge);
  node->setLayoutPadding(
      node->getLeadingPadding(flexColumnDirection, ownerWidth).unwrap(),
      YGEdgeTop);
  node->setLayoutPadding(
      node->getTrailingPadding(flexColumnDirection, ownerWidth).unwrap(),
      YGEdgeBottom);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  if (node->hasMeasureFunc()) {
    measureNodeWithMeasureFunc(
        node,
        availableWidth - marginAxisRow,
        availableHeight - marginAxisColumn,
<<<<<<< HEAD
        widthSizingMode,
        heightSizingMode,
=======
        widthMeasureMode,
        heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        ownerWidth,
        ownerHeight,
        layoutMarkerData,
        reason);
    return;
  }

  const auto childCount = node->getChildCount();
  if (childCount == 0) {
    measureNodeWithoutChildren(
        node,
        availableWidth - marginAxisRow,
        availableHeight - marginAxisColumn,
<<<<<<< HEAD
        widthSizingMode,
        heightSizingMode,
=======
        widthMeasureMode,
        heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        ownerWidth,
        ownerHeight);
    return;
  }

  // If we're not being asked to perform a full layout we can skip the algorithm
  // if we already know the size
  if (!performLayout &&
      measureNodeWithFixedSize(
          node,
          availableWidth - marginAxisRow,
          availableHeight - marginAxisColumn,
<<<<<<< HEAD
          widthSizingMode,
          heightSizingMode,
=======
          widthMeasureMode,
          heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          ownerWidth,
          ownerHeight)) {
    return;
  }

  // At this point we know we're going to perform work. Ensure that each child
  // has a mutable copy.
  node->cloneChildrenIfNeeded();
  // Reset layout flags, as they could have changed.
  node->setLayoutHadOverflow(false);

  // STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM
  const FlexDirection mainAxis =
<<<<<<< HEAD
      resolveDirection(node->style().flexDirection(), direction);
  const FlexDirection crossAxis = resolveCrossDirection(mainAxis, direction);
  const bool isMainAxisRow = isRow(mainAxis);
  const bool isNodeFlexWrap = node->style().flexWrap() != Wrap::NoWrap;
=======
      resolveDirection(node->getStyle().flexDirection(), direction);
  const FlexDirection crossAxis = resolveCrossDirection(mainAxis, direction);
  const bool isMainAxisRow = isRow(mainAxis);
  const bool isNodeFlexWrap = node->getStyle().flexWrap() != Wrap::NoWrap;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  const float mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight;
  const float crossAxisownerSize = isMainAxisRow ? ownerHeight : ownerWidth;

  const float paddingAndBorderAxisMain =
      paddingAndBorderForAxis(node, mainAxis, ownerWidth);
<<<<<<< HEAD
  const float paddingAndBorderAxisCross =
      paddingAndBorderForAxis(node, crossAxis, ownerWidth);
  const float leadingPaddingAndBorderCross =
      node->style().computeFlexStartPaddingAndBorder(
          crossAxis, direction, ownerWidth);

  SizingMode sizingModeMainDim =
      isMainAxisRow ? widthSizingMode : heightSizingMode;
  SizingMode sizingModeCrossDim =
      isMainAxisRow ? heightSizingMode : widthSizingMode;
=======
  const float leadingPaddingAndBorderCross =
      node->getLeadingPaddingAndBorder(crossAxis, ownerWidth).unwrap();
  const float trailingPaddingAndBorderCross =
      node->getTrailingPaddingAndBorder(crossAxis, ownerWidth).unwrap();
  const float paddingAndBorderAxisCross =
      leadingPaddingAndBorderCross + trailingPaddingAndBorderCross;

  MeasureMode measureModeMainDim =
      isMainAxisRow ? widthMeasureMode : heightMeasureMode;
  MeasureMode measureModeCrossDim =
      isMainAxisRow ? heightMeasureMode : widthMeasureMode;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  const float paddingAndBorderAxisRow =
      isMainAxisRow ? paddingAndBorderAxisMain : paddingAndBorderAxisCross;
  const float paddingAndBorderAxisColumn =
      isMainAxisRow ? paddingAndBorderAxisCross : paddingAndBorderAxisMain;

  // STEP 2: DETERMINE AVAILABLE SIZE IN MAIN AND CROSS DIRECTIONS

  float availableInnerWidth = calculateAvailableInnerDimension(
      node,
<<<<<<< HEAD
      Dimension::Width,
=======
      YGDimensionWidth,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      availableWidth - marginAxisRow,
      paddingAndBorderAxisRow,
      ownerWidth);
  float availableInnerHeight = calculateAvailableInnerDimension(
      node,
<<<<<<< HEAD
      Dimension::Height,
=======
      YGDimensionHeight,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      availableHeight - marginAxisColumn,
      paddingAndBorderAxisColumn,
      ownerHeight);

  float availableInnerMainDim =
      isMainAxisRow ? availableInnerWidth : availableInnerHeight;
  const float availableInnerCrossDim =
      isMainAxisRow ? availableInnerHeight : availableInnerWidth;

  // STEP 3: DETERMINE FLEX BASIS FOR EACH ITEM

  // Computed basis + margins + gap
  float totalMainDim = 0;
  totalMainDim += computeFlexBasisForChildren(
      node,
      availableInnerWidth,
      availableInnerHeight,
<<<<<<< HEAD
      widthSizingMode,
      heightSizingMode,
=======
      widthMeasureMode,
      heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      direction,
      mainAxis,
      performLayout,
      layoutMarkerData,
      depth,
      generationCount);

  if (childCount > 1) {
<<<<<<< HEAD
    totalMainDim += node->style().computeGapForAxis(mainAxis) *
=======
    totalMainDim +=
        node->getGapForAxis(mainAxis, availableInnerCrossDim).unwrap() *
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        static_cast<float>(childCount - 1);
  }

  const bool mainAxisOverflows =
<<<<<<< HEAD
      (sizingModeMainDim != SizingMode::MaxContent) &&
      totalMainDim > availableInnerMainDim;

  if (isNodeFlexWrap && mainAxisOverflows &&
      sizingModeMainDim == SizingMode::FitContent) {
    sizingModeMainDim = SizingMode::StretchFit;
=======
      (measureModeMainDim != MeasureMode::Undefined) &&
      totalMainDim > availableInnerMainDim;

  if (isNodeFlexWrap && mainAxisOverflows &&
      measureModeMainDim == MeasureMode::AtMost) {
    measureModeMainDim = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }
  // STEP 4: COLLECT FLEX ITEMS INTO FLEX LINES

  // Indexes of children that represent the first and last items in the line.
  size_t startOfLineIndex = 0;
  size_t endOfLineIndex = 0;

  // Number of lines.
  size_t lineCount = 0;

  // Accumulated cross dimensions of all lines so far.
  float totalLineCrossDim = 0;

<<<<<<< HEAD
  const float crossAxisGap = node->style().computeGapForAxis(crossAxis);
=======
  const float crossAxisGap =
      node->getGapForAxis(crossAxis, availableInnerCrossDim).unwrap();
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  // Max main dimension of all the lines.
  float maxLineMainDim = 0;
  for (; endOfLineIndex < childCount;
       lineCount++, startOfLineIndex = endOfLineIndex) {
    auto flexLine = calculateFlexLine(
        node,
        ownerDirection,
        mainAxisownerSize,
        availableInnerWidth,
        availableInnerMainDim,
        startOfLineIndex,
        lineCount);

    endOfLineIndex = flexLine.endOfLineIndex;

    // If we don't need to measure the cross axis, we can skip the entire flex
    // step.
    const bool canSkipFlex =
<<<<<<< HEAD
        !performLayout && sizingModeCrossDim == SizingMode::StretchFit;
=======
        !performLayout && measureModeCrossDim == MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    // STEP 5: RESOLVING FLEXIBLE LENGTHS ON MAIN AXIS
    // Calculate the remaining available space that needs to be allocated. If
    // the main dimension size isn't known, it is computed based on the line
    // length, so there's no more space left to distribute.

    bool sizeBasedOnContent = false;
    // If we don't measure with exact main dimension we want to ensure we don't
    // violate min and max
<<<<<<< HEAD
    if (sizingModeMainDim != SizingMode::StretchFit) {
      const auto& style = node->style();
      const float minInnerWidth =
          style.minDimension(Dimension::Width).resolve(ownerWidth).unwrap() -
          paddingAndBorderAxisRow;
      const float maxInnerWidth =
          style.maxDimension(Dimension::Width).resolve(ownerWidth).unwrap() -
          paddingAndBorderAxisRow;
      const float minInnerHeight =
          style.minDimension(Dimension::Height).resolve(ownerHeight).unwrap() -
          paddingAndBorderAxisColumn;
      const float maxInnerHeight =
          style.maxDimension(Dimension::Height).resolve(ownerHeight).unwrap() -
=======
    if (measureModeMainDim != MeasureMode::Exactly) {
      const auto& style = node->getStyle();
      const float minInnerWidth =
          yoga::resolveValue(style.minDimension(YGDimensionWidth), ownerWidth)
              .unwrap() -
          paddingAndBorderAxisRow;
      const float maxInnerWidth =
          yoga::resolveValue(style.maxDimension(YGDimensionWidth), ownerWidth)
              .unwrap() -
          paddingAndBorderAxisRow;
      const float minInnerHeight =
          yoga::resolveValue(style.minDimension(YGDimensionHeight), ownerHeight)
              .unwrap() -
          paddingAndBorderAxisColumn;
      const float maxInnerHeight =
          yoga::resolveValue(style.maxDimension(YGDimensionHeight), ownerHeight)
              .unwrap() -
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          paddingAndBorderAxisColumn;

      const float minInnerMainDim =
          isMainAxisRow ? minInnerWidth : minInnerHeight;
      const float maxInnerMainDim =
          isMainAxisRow ? maxInnerWidth : maxInnerHeight;

<<<<<<< HEAD
      if (yoga::isDefined(minInnerMainDim) &&
          flexLine.sizeConsumed < minInnerMainDim) {
        availableInnerMainDim = minInnerMainDim;
      } else if (
          yoga::isDefined(maxInnerMainDim) &&
=======
      if (!yoga::isUndefined(minInnerMainDim) &&
          flexLine.sizeConsumed < minInnerMainDim) {
        availableInnerMainDim = minInnerMainDim;
      } else if (
          !yoga::isUndefined(maxInnerMainDim) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          flexLine.sizeConsumed > maxInnerMainDim) {
        availableInnerMainDim = maxInnerMainDim;
      } else {
        bool useLegacyStretchBehaviour =
            node->hasErrata(Errata::StretchFlexBasis);

        if (!useLegacyStretchBehaviour &&
<<<<<<< HEAD
            ((yoga::isDefined(flexLine.layout.totalFlexGrowFactors) &&
              flexLine.layout.totalFlexGrowFactors == 0) ||
             (yoga::isDefined(node->resolveFlexGrow()) &&
=======
            ((!yoga::isUndefined(flexLine.layout.totalFlexGrowFactors) &&
              flexLine.layout.totalFlexGrowFactors == 0) ||
             (!yoga::isUndefined(node->resolveFlexGrow()) &&
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
              node->resolveFlexGrow() == 0))) {
          // If we don't have any children to flex or we can't flex the node
          // itself, space we've used is all space we need. Root node also
          // should be shrunk to minimum
          availableInnerMainDim = flexLine.sizeConsumed;
        }

        sizeBasedOnContent = !useLegacyStretchBehaviour;
      }
    }

<<<<<<< HEAD
    if (!sizeBasedOnContent && yoga::isDefined(availableInnerMainDim)) {
=======
    if (!sizeBasedOnContent && !yoga::isUndefined(availableInnerMainDim)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      flexLine.layout.remainingFreeSpace =
          availableInnerMainDim - flexLine.sizeConsumed;
    } else if (flexLine.sizeConsumed < 0) {
      // availableInnerMainDim is indefinite which means the node is being sized
      // based on its content. sizeConsumed is negative which means
      // the node will allocate 0 points for its content. Consequently,
      // remainingFreeSpace is 0 - sizeConsumed.
      flexLine.layout.remainingFreeSpace = -flexLine.sizeConsumed;
    }

    if (!canSkipFlex) {
      resolveFlexibleLength(
          node,
          flexLine,
          mainAxis,
          crossAxis,
<<<<<<< HEAD
          direction,
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          mainAxisownerSize,
          availableInnerMainDim,
          availableInnerCrossDim,
          availableInnerWidth,
          availableInnerHeight,
          mainAxisOverflows,
<<<<<<< HEAD
          sizingModeCrossDim,
=======
          measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          performLayout,
          layoutMarkerData,
          depth,
          generationCount);
    }

    node->setLayoutHadOverflow(
<<<<<<< HEAD
        node->getLayout().hadOverflow() ||
=======
        node->getLayout().hadOverflow() |
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        (flexLine.layout.remainingFreeSpace < 0));

    // STEP 6: MAIN-AXIS JUSTIFICATION & CROSS-AXIS SIZE DETERMINATION

    // At this point, all the children have their dimensions set in the main
    // axis. Their dimensions are also set in the cross axis with the exception
    // of items that are aligned "stretch". We need to compute these stretch
    // values and set the final positions.

    justifyMainAxis(
        node,
        flexLine,
        startOfLineIndex,
        mainAxis,
        crossAxis,
<<<<<<< HEAD
        direction,
        sizingModeMainDim,
        sizingModeCrossDim,
=======
        measureModeMainDim,
        measureModeCrossDim,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        mainAxisownerSize,
        ownerWidth,
        availableInnerMainDim,
        availableInnerCrossDim,
        availableInnerWidth,
        performLayout);

    float containerCrossAxis = availableInnerCrossDim;
<<<<<<< HEAD
    if (sizingModeCrossDim == SizingMode::MaxContent ||
        sizingModeCrossDim == SizingMode::FitContent) {
=======
    if (measureModeCrossDim == MeasureMode::Undefined ||
        measureModeCrossDim == MeasureMode::AtMost) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      // Compute the cross axis from the max cross dimension of the children.
      containerCrossAxis =
          boundAxis(
              node,
              crossAxis,
              flexLine.layout.crossDim + paddingAndBorderAxisCross,
              crossAxisownerSize,
              ownerWidth) -
          paddingAndBorderAxisCross;
    }

    // If there's no flex wrap, the cross dimension is defined by the container.
<<<<<<< HEAD
    if (!isNodeFlexWrap && sizingModeCrossDim == SizingMode::StretchFit) {
      flexLine.layout.crossDim = availableInnerCrossDim;
    }

    // As-per https://www.w3.org/TR/css-flexbox-1/#cross-sizing, the
    // cross-size of the line within a single-line container should be bound to
    // min/max constraints before alignment within the line. In a multi-line
    // container, affecting alignment between the lines.
    if (!isNodeFlexWrap) {
      flexLine.layout.crossDim =
          boundAxis(
              node,
              crossAxis,
              flexLine.layout.crossDim + paddingAndBorderAxisCross,
              crossAxisownerSize,
              ownerWidth) -
          paddingAndBorderAxisCross;
    }
=======
    if (!isNodeFlexWrap && measureModeCrossDim == MeasureMode::Exactly) {
      flexLine.layout.crossDim = availableInnerCrossDim;
    }

    // Clamp to the min/max size specified on the container.
    flexLine.layout.crossDim =
        boundAxis(
            node,
            crossAxis,
            flexLine.layout.crossDim + paddingAndBorderAxisCross,
            crossAxisownerSize,
            ownerWidth) -
        paddingAndBorderAxisCross;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    // STEP 7: CROSS-AXIS ALIGNMENT
    // We can skip child alignment if we're just measuring the container.
    if (performLayout) {
      for (size_t i = startOfLineIndex; i < endOfLineIndex; i++) {
        const auto child = node->getChild(i);
<<<<<<< HEAD
        if (child->style().display() == Display::None) {
          continue;
        }
        if (child->style().positionType() == PositionType::Absolute) {
=======
        if (child->getStyle().display() == Display::None) {
          continue;
        }
        if (child->getStyle().positionType() == PositionType::Absolute) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          // If the child is absolutely positioned and has a
          // top/left/bottom/right set, override all the previously computed
          // positions to set it correctly.
          const bool isChildLeadingPosDefined =
<<<<<<< HEAD
              child->style().isFlexStartPositionDefined(crossAxis, direction);
          if (isChildLeadingPosDefined) {
            child->setLayoutPosition(
                child->style().computeFlexStartPosition(
                    crossAxis, direction, availableInnerCrossDim) +
                    node->style().computeFlexStartBorder(crossAxis, direction) +
                    child->style().computeFlexStartMargin(
                        crossAxis, direction, availableInnerWidth),
                flexStartEdge(crossAxis));
=======
              child->isLeadingPositionDefined(crossAxis);
          if (isChildLeadingPosDefined) {
            child->setLayoutPosition(
                child->getLeadingPosition(crossAxis, availableInnerCrossDim)
                        .unwrap() +
                    node->getLeadingBorder(crossAxis) +
                    child->getLeadingMargin(crossAxis, availableInnerWidth)
                        .unwrap(),
                leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          }
          // If leading position is not defined or calculations result in Nan,
          // default to border + margin
          if (!isChildLeadingPosDefined ||
              yoga::isUndefined(
<<<<<<< HEAD
                  child->getLayout().position(flexStartEdge(crossAxis)))) {
            child->setLayoutPosition(
                node->style().computeFlexStartBorder(crossAxis, direction) +
                    child->style().computeFlexStartMargin(
                        crossAxis, direction, availableInnerWidth),
                flexStartEdge(crossAxis));
=======
                  child->getLayout().position[leadingEdge(crossAxis)])) {
            child->setLayoutPosition(
                node->getLeadingBorder(crossAxis) +
                    child->getLeadingMargin(crossAxis, availableInnerWidth)
                        .unwrap(),
                leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          }
        } else {
          float leadingCrossDim = leadingPaddingAndBorderCross;

          // For a relative children, we're either using alignItems (owner) or
          // alignSelf (child) in order to determine the position in the cross
          // axis
          const Align alignItem = resolveChildAlignment(node, child);

          // If the child uses align stretch, we need to lay it out one more
          // time, this time forcing the cross-axis size to be the computed
          // cross size for the current line.
          if (alignItem == Align::Stretch &&
<<<<<<< HEAD
              !child->style().flexStartMarginIsAuto(crossAxis, direction) &&
              !child->style().flexEndMarginIsAuto(crossAxis, direction)) {
            // If the child defines a definite size for its cross axis, there's
            // no need to stretch.
            if (!child->hasDefiniteLength(
                    dimension(crossAxis), availableInnerCrossDim)) {
              float childMainSize =
                  child->getLayout().measuredDimension(dimension(mainAxis));
              const auto& childStyle = child->style();
              float childCrossSize = childStyle.aspectRatio().isDefined()
                  ? child->style().computeMarginForAxis(
                        crossAxis, availableInnerWidth) +
=======
              child->marginLeadingValue(crossAxis).unit != YGUnitAuto &&
              child->marginTrailingValue(crossAxis).unit != YGUnitAuto) {
            // If the child defines a definite size for its cross axis, there's
            // no need to stretch.
            if (!styleDefinesDimension(
                    child, crossAxis, availableInnerCrossDim)) {
              float childMainSize =
                  child->getLayout().measuredDimension(dimension(mainAxis));
              const auto& childStyle = child->getStyle();
              float childCrossSize = !childStyle.aspectRatio().isUndefined()
                  ? child->getMarginForAxis(crossAxis, availableInnerWidth)
                          .unwrap() +
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                      (isMainAxisRow
                           ? childMainSize / childStyle.aspectRatio().unwrap()
                           : childMainSize * childStyle.aspectRatio().unwrap())
                  : flexLine.layout.crossDim;

<<<<<<< HEAD
              childMainSize += child->style().computeMarginForAxis(
                  mainAxis, availableInnerWidth);

              SizingMode childMainSizingMode = SizingMode::StretchFit;
              SizingMode childCrossSizingMode = SizingMode::StretchFit;
=======
              childMainSize +=
                  child->getMarginForAxis(mainAxis, availableInnerWidth)
                      .unwrap();

              MeasureMode childMainMeasureMode = MeasureMode::Exactly;
              MeasureMode childCrossMeasureMode = MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
              constrainMaxSizeForMode(
                  child,
                  mainAxis,
                  availableInnerMainDim,
                  availableInnerWidth,
<<<<<<< HEAD
                  &childMainSizingMode,
=======
                  &childMainMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                  &childMainSize);
              constrainMaxSizeForMode(
                  child,
                  crossAxis,
                  availableInnerCrossDim,
                  availableInnerWidth,
<<<<<<< HEAD
                  &childCrossSizingMode,
=======
                  &childCrossMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                  &childCrossSize);

              const float childWidth =
                  isMainAxisRow ? childMainSize : childCrossSize;
              const float childHeight =
                  !isMainAxisRow ? childMainSize : childCrossSize;

<<<<<<< HEAD
              auto alignContent = node->style().alignContent();
              auto crossAxisDoesNotGrow =
                  alignContent != Align::Stretch && isNodeFlexWrap;
              const SizingMode childWidthSizingMode =
                  yoga::isUndefined(childWidth) ||
                      (!isMainAxisRow && crossAxisDoesNotGrow)
                  ? SizingMode::MaxContent
                  : SizingMode::StretchFit;
              const SizingMode childHeightSizingMode =
                  yoga::isUndefined(childHeight) ||
                      (isMainAxisRow && crossAxisDoesNotGrow)
                  ? SizingMode::MaxContent
                  : SizingMode::StretchFit;
=======
              auto alignContent = node->getStyle().alignContent();
              auto crossAxisDoesNotGrow =
                  alignContent != Align::Stretch && isNodeFlexWrap;
              const MeasureMode childWidthMeasureMode =
                  yoga::isUndefined(childWidth) ||
                      (!isMainAxisRow && crossAxisDoesNotGrow)
                  ? MeasureMode::Undefined
                  : MeasureMode::Exactly;
              const MeasureMode childHeightMeasureMode =
                  yoga::isUndefined(childHeight) ||
                      (isMainAxisRow && crossAxisDoesNotGrow)
                  ? MeasureMode::Undefined
                  : MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

              calculateLayoutInternal(
                  child,
                  childWidth,
                  childHeight,
                  direction,
<<<<<<< HEAD
                  childWidthSizingMode,
                  childHeightSizingMode,
=======
                  childWidthMeasureMode,
                  childHeightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                  availableInnerWidth,
                  availableInnerHeight,
                  true,
                  LayoutPassReason::kStretch,
                  layoutMarkerData,
                  depth,
                  generationCount);
            }
          } else {
            const float remainingCrossDim = containerCrossAxis -
<<<<<<< HEAD
                child->dimensionWithMargin(crossAxis, availableInnerWidth);

            if (child->style().flexStartMarginIsAuto(crossAxis, direction) &&
                child->style().flexEndMarginIsAuto(crossAxis, direction)) {
              leadingCrossDim +=
                  yoga::maxOrDefined(0.0f, remainingCrossDim / 2);
            } else if (child->style().flexEndMarginIsAuto(
                           crossAxis, direction)) {
              // No-Op
            } else if (child->style().flexStartMarginIsAuto(
                           crossAxis, direction)) {
=======
                dimensionWithMargin(child, crossAxis, availableInnerWidth);

            if (child->marginLeadingValue(crossAxis).unit == YGUnitAuto &&
                child->marginTrailingValue(crossAxis).unit == YGUnitAuto) {
              leadingCrossDim +=
                  yoga::maxOrDefined(0.0f, remainingCrossDim / 2);
            } else if (
                child->marginTrailingValue(crossAxis).unit == YGUnitAuto) {
              // No-Op
            } else if (
                child->marginLeadingValue(crossAxis).unit == YGUnitAuto) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
              leadingCrossDim += yoga::maxOrDefined(0.0f, remainingCrossDim);
            } else if (alignItem == Align::FlexStart) {
              // No-Op
            } else if (alignItem == Align::Center) {
              leadingCrossDim += remainingCrossDim / 2;
            } else {
              leadingCrossDim += remainingCrossDim;
            }
          }
          // And we apply the position
          child->setLayoutPosition(
<<<<<<< HEAD
              child->getLayout().position(flexStartEdge(crossAxis)) +
                  totalLineCrossDim + leadingCrossDim,
              flexStartEdge(crossAxis));
=======
              child->getLayout().position[leadingEdge(crossAxis)] +
                  totalLineCrossDim + leadingCrossDim,
              leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        }
      }
    }

    const float appliedCrossGap = lineCount != 0 ? crossAxisGap : 0.0f;
    totalLineCrossDim += flexLine.layout.crossDim + appliedCrossGap;
    maxLineMainDim =
        yoga::maxOrDefined(maxLineMainDim, flexLine.layout.mainDim);
  }

  // STEP 8: MULTI-LINE CONTENT ALIGNMENT
  // currentLead stores the size of the cross dim
  if (performLayout && (isNodeFlexWrap || isBaselineLayout(node))) {
<<<<<<< HEAD
    float leadPerLine = 0;
    float currentLead = leadingPaddingAndBorderCross;

    const float unclampedCrossDim = sizingModeCrossDim == SizingMode::StretchFit
        ? availableInnerCrossDim + paddingAndBorderAxisCross
        : node->hasDefiniteLength(dimension(crossAxis), crossAxisownerSize)
        ? node->getResolvedDimension(dimension(crossAxis))
              .resolve(crossAxisownerSize)
              .unwrap()
        : totalLineCrossDim + paddingAndBorderAxisCross;

    const float innerCrossDim =
        boundAxis(node, crossAxis, unclampedCrossDim, ownerHeight, ownerWidth) -
        paddingAndBorderAxisCross;

    const float remainingAlignContentDim = innerCrossDim - totalLineCrossDim;
    switch (node->style().alignContent()) {
      case Align::FlexEnd:
        currentLead += remainingAlignContentDim;
        break;
      case Align::Center:
        currentLead += remainingAlignContentDim / 2;
        break;
      case Align::Stretch:
        if (innerCrossDim > totalLineCrossDim) {
          leadPerLine =
              remainingAlignContentDim / static_cast<float>(lineCount);
        }
        break;
      case Align::SpaceAround:
        if (innerCrossDim > totalLineCrossDim) {
          currentLead +=
              remainingAlignContentDim / (2 * static_cast<float>(lineCount));
          leadPerLine =
              remainingAlignContentDim / static_cast<float>(lineCount);
        } else {
          currentLead += remainingAlignContentDim / 2;
        }
        break;
      case Align::SpaceEvenly:
        if (innerCrossDim > totalLineCrossDim) {
          currentLead +=
              remainingAlignContentDim / static_cast<float>(lineCount + 1);
          leadPerLine =
              remainingAlignContentDim / static_cast<float>(lineCount + 1);
        } else {
          currentLead += remainingAlignContentDim / 2;
        }
        break;
      case Align::SpaceBetween:
        if (innerCrossDim > totalLineCrossDim && lineCount > 1) {
          leadPerLine =
              remainingAlignContentDim / static_cast<float>(lineCount - 1);
        }
        break;
      case Align::Auto:
      case Align::FlexStart:
      case Align::Baseline:
        break;
=======
    float crossDimLead = 0;
    float currentLead = leadingPaddingAndBorderCross;
    if (!yoga::isUndefined(availableInnerCrossDim)) {
      const float remainingAlignContentDim =
          availableInnerCrossDim - totalLineCrossDim;
      switch (node->getStyle().alignContent()) {
        case Align::FlexEnd:
          currentLead += remainingAlignContentDim;
          break;
        case Align::Center:
          currentLead += remainingAlignContentDim / 2;
          break;
        case Align::Stretch:
          if (availableInnerCrossDim > totalLineCrossDim) {
            crossDimLead =
                remainingAlignContentDim / static_cast<float>(lineCount);
          }
          break;
        case Align::SpaceAround:
          if (availableInnerCrossDim > totalLineCrossDim) {
            currentLead +=
                remainingAlignContentDim / (2 * static_cast<float>(lineCount));
            if (lineCount > 1) {
              crossDimLead =
                  remainingAlignContentDim / static_cast<float>(lineCount);
            }
          } else {
            currentLead += remainingAlignContentDim / 2;
          }
          break;
        case Align::SpaceBetween:
          if (availableInnerCrossDim > totalLineCrossDim && lineCount > 1) {
            crossDimLead =
                remainingAlignContentDim / static_cast<float>(lineCount - 1);
          }
          break;
        case Align::Auto:
        case Align::FlexStart:
        case Align::Baseline:
          break;
      }
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    }
    size_t endIndex = 0;
    for (size_t i = 0; i < lineCount; i++) {
      const size_t startIndex = endIndex;
      size_t ii;

      // compute the line's height and find the endIndex
      float lineHeight = 0;
      float maxAscentForCurrentLine = 0;
      float maxDescentForCurrentLine = 0;
      for (ii = startIndex; ii < childCount; ii++) {
        const auto child = node->getChild(ii);
<<<<<<< HEAD
        if (child->style().display() == Display::None) {
          continue;
        }
        if (child->style().positionType() != PositionType::Absolute) {
          if (child->getLineIndex() != i) {
            break;
          }
          if (child->isLayoutDimensionDefined(crossAxis)) {
            lineHeight = yoga::maxOrDefined(
                lineHeight,
                child->getLayout().measuredDimension(dimension(crossAxis)) +
                    child->style().computeMarginForAxis(
                        crossAxis, availableInnerWidth));
          }
          if (resolveChildAlignment(node, child) == Align::Baseline) {
            const float ascent = calculateBaseline(child) +
                child->style().computeFlexStartMargin(
                    FlexDirection::Column, direction, availableInnerWidth);
            const float descent =
                child->getLayout().measuredDimension(Dimension::Height) +
                child->style().computeMarginForAxis(
                    FlexDirection::Column, availableInnerWidth) -
=======
        if (child->getStyle().display() == Display::None) {
          continue;
        }
        if (child->getStyle().positionType() != PositionType::Absolute) {
          if (child->getLineIndex() != i) {
            break;
          }
          if (isLayoutDimensionDefined(child, crossAxis)) {
            lineHeight = yoga::maxOrDefined(
                lineHeight,
                child->getLayout().measuredDimension(dimension(crossAxis)) +
                    child->getMarginForAxis(crossAxis, availableInnerWidth)
                        .unwrap());
          }
          if (resolveChildAlignment(node, child) == Align::Baseline) {
            const float ascent = calculateBaseline(child) +
                child
                    ->getLeadingMargin(
                        FlexDirection::Column, availableInnerWidth)
                    .unwrap();
            const float descent =
                child->getLayout().measuredDimension(YGDimensionHeight) +
                child
                    ->getMarginForAxis(
                        FlexDirection::Column, availableInnerWidth)
                    .unwrap() -
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                ascent;
            maxAscentForCurrentLine =
                yoga::maxOrDefined(maxAscentForCurrentLine, ascent);
            maxDescentForCurrentLine =
                yoga::maxOrDefined(maxDescentForCurrentLine, descent);
            lineHeight = yoga::maxOrDefined(
                lineHeight, maxAscentForCurrentLine + maxDescentForCurrentLine);
          }
        }
      }
      endIndex = ii;
<<<<<<< HEAD
=======
      lineHeight += crossDimLead;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      currentLead += i != 0 ? crossAxisGap : 0;

      if (performLayout) {
        for (ii = startIndex; ii < endIndex; ii++) {
          const auto child = node->getChild(ii);
<<<<<<< HEAD
          if (child->style().display() == Display::None) {
            continue;
          }
          if (child->style().positionType() != PositionType::Absolute) {
=======
          if (child->getStyle().display() == Display::None) {
            continue;
          }
          if (child->getStyle().positionType() != PositionType::Absolute) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
            switch (resolveChildAlignment(node, child)) {
              case Align::FlexStart: {
                child->setLayoutPosition(
                    currentLead +
<<<<<<< HEAD
                        child->style().computeFlexStartPosition(
                            crossAxis, direction, availableInnerWidth),
                    flexStartEdge(crossAxis));
=======
                        child->getLeadingMargin(crossAxis, availableInnerWidth)
                            .unwrap(),
                    leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                break;
              }
              case Align::FlexEnd: {
                child->setLayoutPosition(
                    currentLead + lineHeight -
<<<<<<< HEAD
                        child->style().computeFlexEndMargin(
                            crossAxis, direction, availableInnerWidth) -
                        child->getLayout().measuredDimension(
                            dimension(crossAxis)),
                    flexStartEdge(crossAxis));
=======
                        child->getTrailingMargin(crossAxis, availableInnerWidth)
                            .unwrap() -
                        child->getLayout().measuredDimension(
                            dimension(crossAxis)),
                    leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                break;
              }
              case Align::Center: {
                float childHeight =
                    child->getLayout().measuredDimension(dimension(crossAxis));

                child->setLayoutPosition(
                    currentLead + (lineHeight - childHeight) / 2,
<<<<<<< HEAD
                    flexStartEdge(crossAxis));
=======
                    leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                break;
              }
              case Align::Stretch: {
                child->setLayoutPosition(
                    currentLead +
<<<<<<< HEAD
                        child->style().computeFlexStartMargin(
                            crossAxis, direction, availableInnerWidth),
                    flexStartEdge(crossAxis));

                // Remeasure child with the line height as it as been only
                // measured with the owners height yet.
                if (!child->hasDefiniteLength(
                        dimension(crossAxis), availableInnerCrossDim)) {
                  const float childWidth = isMainAxisRow
                      ? (child->getLayout().measuredDimension(
                             Dimension::Width) +
                         child->style().computeMarginForAxis(
                             mainAxis, availableInnerWidth))
                      : leadPerLine + lineHeight;

                  const float childHeight = !isMainAxisRow
                      ? (child->getLayout().measuredDimension(
                             Dimension::Height) +
                         child->style().computeMarginForAxis(
                             crossAxis, availableInnerWidth))
                      : leadPerLine + lineHeight;
=======
                        child->getLeadingMargin(crossAxis, availableInnerWidth)
                            .unwrap(),
                    leadingEdge(crossAxis));

                // Remeasure child with the line height as it as been only
                // measured with the owners height yet.
                if (!styleDefinesDimension(
                        child, crossAxis, availableInnerCrossDim)) {
                  const float childWidth = isMainAxisRow
                      ? (child->getLayout().measuredDimension(
                             YGDimensionWidth) +
                         child->getMarginForAxis(mainAxis, availableInnerWidth)
                             .unwrap())
                      : lineHeight;

                  const float childHeight = !isMainAxisRow
                      ? (child->getLayout().measuredDimension(
                             YGDimensionHeight) +
                         child->getMarginForAxis(crossAxis, availableInnerWidth)
                             .unwrap())
                      : lineHeight;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

                  if (!(yoga::inexactEquals(
                            childWidth,
                            child->getLayout().measuredDimension(
<<<<<<< HEAD
                                Dimension::Width)) &&
                        yoga::inexactEquals(
                            childHeight,
                            child->getLayout().measuredDimension(
                                Dimension::Height)))) {
=======
                                YGDimensionWidth)) &&
                        yoga::inexactEquals(
                            childHeight,
                            child->getLayout().measuredDimension(
                                YGDimensionHeight)))) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                    calculateLayoutInternal(
                        child,
                        childWidth,
                        childHeight,
                        direction,
<<<<<<< HEAD
                        SizingMode::StretchFit,
                        SizingMode::StretchFit,
=======
                        MeasureMode::Exactly,
                        MeasureMode::Exactly,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                        availableInnerWidth,
                        availableInnerHeight,
                        true,
                        LayoutPassReason::kMultilineStretch,
                        layoutMarkerData,
                        depth,
                        generationCount);
                  }
                }
                break;
              }
              case Align::Baseline: {
                child->setLayoutPosition(
                    currentLead + maxAscentForCurrentLine -
                        calculateBaseline(child) +
<<<<<<< HEAD
                        child->style().computeFlexStartPosition(
                            FlexDirection::Column,
                            direction,
                            availableInnerCrossDim),
                    PhysicalEdge::Top);
=======
                        child
                            ->getLeadingPosition(
                                FlexDirection::Column, availableInnerCrossDim)
                            .unwrap(),
                    YGEdgeTop);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

                break;
              }
              case Align::Auto:
              case Align::SpaceBetween:
              case Align::SpaceAround:
<<<<<<< HEAD
              case Align::SpaceEvenly:
=======
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                break;
            }
          }
        }
      }
<<<<<<< HEAD
      currentLead = currentLead + leadPerLine + lineHeight;
=======
      currentLead += lineHeight;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    }
  }

  // STEP 9: COMPUTING FINAL DIMENSIONS

  node->setLayoutMeasuredDimension(
      boundAxis(
          node,
          FlexDirection::Row,
          availableWidth - marginAxisRow,
          ownerWidth,
          ownerWidth),
<<<<<<< HEAD
      Dimension::Width);
=======
      YGDimensionWidth);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

  node->setLayoutMeasuredDimension(
      boundAxis(
          node,
          FlexDirection::Column,
          availableHeight - marginAxisColumn,
          ownerHeight,
          ownerWidth),
<<<<<<< HEAD
      Dimension::Height);

  // If the user didn't specify a width or height for the node, set the
  // dimensions based on the children.
  if (sizingModeMainDim == SizingMode::MaxContent ||
      (node->style().overflow() != Overflow::Scroll &&
       sizingModeMainDim == SizingMode::FitContent)) {
=======
      YGDimensionHeight);

  // If the user didn't specify a width or height for the node, set the
  // dimensions based on the children.
  if (measureModeMainDim == MeasureMode::Undefined ||
      (node->getStyle().overflow() != Overflow::Scroll &&
       measureModeMainDim == MeasureMode::AtMost)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    // Clamp the size to the min/max size, if specified, and make sure it
    // doesn't go below the padding and border amount.
    node->setLayoutMeasuredDimension(
        boundAxis(
            node, mainAxis, maxLineMainDim, mainAxisownerSize, ownerWidth),
        dimension(mainAxis));

  } else if (
<<<<<<< HEAD
      sizingModeMainDim == SizingMode::FitContent &&
      node->style().overflow() == Overflow::Scroll) {
=======
      measureModeMainDim == MeasureMode::AtMost &&
      node->getStyle().overflow() == Overflow::Scroll) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    node->setLayoutMeasuredDimension(
        yoga::maxOrDefined(
            yoga::minOrDefined(
                availableInnerMainDim + paddingAndBorderAxisMain,
                boundAxisWithinMinAndMax(
                    node,
                    mainAxis,
                    FloatOptional{maxLineMainDim},
                    mainAxisownerSize)
                    .unwrap()),
            paddingAndBorderAxisMain),
        dimension(mainAxis));
  }

<<<<<<< HEAD
  if (sizingModeCrossDim == SizingMode::MaxContent ||
      (node->style().overflow() != Overflow::Scroll &&
       sizingModeCrossDim == SizingMode::FitContent)) {
=======
  if (measureModeCrossDim == MeasureMode::Undefined ||
      (node->getStyle().overflow() != Overflow::Scroll &&
       measureModeCrossDim == MeasureMode::AtMost)) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    // Clamp the size to the min/max size, if specified, and make sure it
    // doesn't go below the padding and border amount.
    node->setLayoutMeasuredDimension(
        boundAxis(
            node,
            crossAxis,
            totalLineCrossDim + paddingAndBorderAxisCross,
            crossAxisownerSize,
            ownerWidth),
        dimension(crossAxis));

  } else if (
<<<<<<< HEAD
      sizingModeCrossDim == SizingMode::FitContent &&
      node->style().overflow() == Overflow::Scroll) {
=======
      measureModeCrossDim == MeasureMode::AtMost &&
      node->getStyle().overflow() == Overflow::Scroll) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    node->setLayoutMeasuredDimension(
        yoga::maxOrDefined(
            yoga::minOrDefined(
                availableInnerCrossDim + paddingAndBorderAxisCross,
                boundAxisWithinMinAndMax(
                    node,
                    crossAxis,
                    FloatOptional{
                        totalLineCrossDim + paddingAndBorderAxisCross},
                    crossAxisownerSize)
                    .unwrap()),
            paddingAndBorderAxisCross),
        dimension(crossAxis));
  }

  // As we only wrapped in normal direction yet, we need to reverse the
  // positions on wrap-reverse.
<<<<<<< HEAD
  if (performLayout && node->style().flexWrap() == Wrap::WrapReverse) {
    for (size_t i = 0; i < childCount; i++) {
      const auto child = node->getChild(i);
      if (child->style().positionType() != PositionType::Absolute) {
        child->setLayoutPosition(
            node->getLayout().measuredDimension(dimension(crossAxis)) -
                child->getLayout().position(flexStartEdge(crossAxis)) -
                child->getLayout().measuredDimension(dimension(crossAxis)),
            flexStartEdge(crossAxis));
=======
  if (performLayout && node->getStyle().flexWrap() == Wrap::WrapReverse) {
    for (size_t i = 0; i < childCount; i++) {
      const auto child = node->getChild(i);
      if (child->getStyle().positionType() != PositionType::Absolute) {
        child->setLayoutPosition(
            node->getLayout().measuredDimension(dimension(crossAxis)) -
                child->getLayout().position[leadingEdge(crossAxis)] -
                child->getLayout().measuredDimension(dimension(crossAxis)),
            leadingEdge(crossAxis));
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      }
    }
  }

  if (performLayout) {
<<<<<<< HEAD
    // STEP 10: SETTING TRAILING POSITIONS FOR CHILDREN
    const bool needsMainTrailingPos = needsTrailingPosition(mainAxis);
    const bool needsCrossTrailingPos = needsTrailingPosition(crossAxis);

    if (needsMainTrailingPos || needsCrossTrailingPos) {
      for (size_t i = 0; i < childCount; i++) {
        const auto child = node->getChild(i);
        // Absolute children will be handled by their containing block since we
        // cannot guarantee that their positions are set when their parents are
        // done with layout.
        if (child->style().display() == Display::None ||
            child->style().positionType() == PositionType::Absolute) {
=======
    // STEP 10: SIZING AND POSITIONING ABSOLUTE CHILDREN
    for (auto child : node->getChildren()) {
      if (child->getStyle().display() == Display::None ||
          child->getStyle().positionType() != PositionType::Absolute) {
        continue;
      }
      const bool absolutePercentageAgainstPaddingEdge =
          node->getConfig()->isExperimentalFeatureEnabled(
              ExperimentalFeature::AbsolutePercentageAgainstPaddingEdge);

      layoutAbsoluteChild(
          node,
          child,
          absolutePercentageAgainstPaddingEdge
              ? node->getLayout().measuredDimension(YGDimensionWidth)
              : availableInnerWidth,
          isMainAxisRow ? measureModeMainDim : measureModeCrossDim,
          absolutePercentageAgainstPaddingEdge
              ? node->getLayout().measuredDimension(YGDimensionHeight)
              : availableInnerHeight,
          direction,
          layoutMarkerData,
          depth,
          generationCount);
    }

    // STEP 11: SETTING TRAILING POSITIONS FOR CHILDREN
    const bool needsMainTrailingPos = mainAxis == FlexDirection::RowReverse ||
        mainAxis == FlexDirection::ColumnReverse;
    const bool needsCrossTrailingPos = crossAxis == FlexDirection::RowReverse ||
        crossAxis == FlexDirection::ColumnReverse;

    // Set trailing position if necessary.
    if (needsMainTrailingPos || needsCrossTrailingPos) {
      for (size_t i = 0; i < childCount; i++) {
        const auto child = node->getChild(i);
        if (child->getStyle().display() == Display::None) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          continue;
        }
        if (needsMainTrailingPos) {
          setChildTrailingPosition(node, child, mainAxis);
        }

        if (needsCrossTrailingPos) {
          setChildTrailingPosition(node, child, crossAxis);
        }
      }
    }
<<<<<<< HEAD

    // STEP 11: SIZING AND POSITIONING ABSOLUTE CHILDREN
    // Let the containing block layout its absolute descendants.
    if (node->style().positionType() != PositionType::Static ||
        node->alwaysFormsContainingBlock() || depth == 1) {
      layoutAbsoluteDescendants(
          node,
          node,
          isMainAxisRow ? sizingModeMainDim : sizingModeCrossDim,
          direction,
          layoutMarkerData,
          depth,
          generationCount,
          0.0f,
          0.0f,
          availableInnerWidth,
          availableInnerHeight);
    }
  }
}

=======
  }
}

bool gPrintChanges = false;
bool gPrintSkips = false;

static const char* spacer =
    "                                                            ";

static const char* spacerWithLength(const unsigned long level) {
  const size_t spacerLen = strlen(spacer);
  if (level > spacerLen) {
    return &spacer[0];
  } else {
    return &spacer[spacerLen - level];
  }
}

static const char* measureModeName(
    const MeasureMode mode,
    const bool performLayout) {
  switch (mode) {
    case MeasureMode::Undefined:
      return performLayout ? "LAY_UNDEFINED" : "UNDEFINED";
    case MeasureMode::Exactly:
      return performLayout ? "LAY_EXACTLY" : "EXACTLY";
    case MeasureMode::AtMost:
      return performLayout ? "LAY_AT_MOST" : "AT_MOST";
  }
  return "";
}

>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
//
// This is a wrapper around the calculateLayoutImpl function. It determines
// whether the layout request is redundant and can be skipped.
//
// Parameters:
//  Input parameters are the same as calculateLayoutImpl (see above)
//  Return parameter is true if layout was performed, false if skipped
//
bool calculateLayoutInternal(
    yoga::Node* const node,
    const float availableWidth,
    const float availableHeight,
    const Direction ownerDirection,
<<<<<<< HEAD
    const SizingMode widthSizingMode,
    const SizingMode heightSizingMode,
=======
    const MeasureMode widthMeasureMode,
    const MeasureMode heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    const float ownerWidth,
    const float ownerHeight,
    const bool performLayout,
    const LayoutPassReason reason,
    LayoutData& layoutMarkerData,
    uint32_t depth,
    const uint32_t generationCount) {
  LayoutResults* layout = &node->getLayout();

  depth++;

  const bool needToVisitNode =
      (node->isDirty() && layout->generationCount != generationCount) ||
      layout->lastOwnerDirection != ownerDirection;

  if (needToVisitNode) {
    // Invalidate the cached results.
    layout->nextCachedMeasurementsIndex = 0;
    layout->cachedLayout.availableWidth = -1;
    layout->cachedLayout.availableHeight = -1;
<<<<<<< HEAD
    layout->cachedLayout.widthSizingMode = SizingMode::MaxContent;
    layout->cachedLayout.heightSizingMode = SizingMode::MaxContent;
=======
    layout->cachedLayout.widthMeasureMode = MeasureMode::Undefined;
    layout->cachedLayout.heightMeasureMode = MeasureMode::Undefined;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    layout->cachedLayout.computedWidth = -1;
    layout->cachedLayout.computedHeight = -1;
  }

  CachedMeasurement* cachedResults = nullptr;

  // Determine whether the results are already cached. We maintain a separate
  // cache for layouts and measurements. A layout operation modifies the
  // positions and dimensions for nodes in the subtree. The algorithm assumes
  // that each node gets laid out a maximum of one time per tree layout, but
  // multiple measurements may be required to resolve all of the flex
  // dimensions. We handle nodes with measure functions specially here because
  // they are the most expensive to measure, so it's worth avoiding redundant
  // measurements if at all possible.
  if (node->hasMeasureFunc()) {
    const float marginAxisRow =
<<<<<<< HEAD
        node->style().computeMarginForAxis(FlexDirection::Row, ownerWidth);
    const float marginAxisColumn =
        node->style().computeMarginForAxis(FlexDirection::Column, ownerWidth);

    // First, try to use the layout cache.
    if (canUseCachedMeasurement(
            widthSizingMode,
            availableWidth,
            heightSizingMode,
            availableHeight,
            layout->cachedLayout.widthSizingMode,
            layout->cachedLayout.availableWidth,
            layout->cachedLayout.heightSizingMode,
=======
        node->getMarginForAxis(FlexDirection::Row, ownerWidth).unwrap();
    const float marginAxisColumn =
        node->getMarginForAxis(FlexDirection::Column, ownerWidth).unwrap();

    // First, try to use the layout cache.
    if (canUseCachedMeasurement(
            widthMeasureMode,
            availableWidth,
            heightMeasureMode,
            availableHeight,
            layout->cachedLayout.widthMeasureMode,
            layout->cachedLayout.availableWidth,
            layout->cachedLayout.heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
            layout->cachedLayout.availableHeight,
            layout->cachedLayout.computedWidth,
            layout->cachedLayout.computedHeight,
            marginAxisRow,
            marginAxisColumn,
            node->getConfig())) {
      cachedResults = &layout->cachedLayout;
    } else {
      // Try to use the measurement cache.
      for (size_t i = 0; i < layout->nextCachedMeasurementsIndex; i++) {
        if (canUseCachedMeasurement(
<<<<<<< HEAD
                widthSizingMode,
                availableWidth,
                heightSizingMode,
                availableHeight,
                layout->cachedMeasurements[i].widthSizingMode,
                layout->cachedMeasurements[i].availableWidth,
                layout->cachedMeasurements[i].heightSizingMode,
=======
                widthMeasureMode,
                availableWidth,
                heightMeasureMode,
                availableHeight,
                layout->cachedMeasurements[i].widthMeasureMode,
                layout->cachedMeasurements[i].availableWidth,
                layout->cachedMeasurements[i].heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
                layout->cachedMeasurements[i].availableHeight,
                layout->cachedMeasurements[i].computedWidth,
                layout->cachedMeasurements[i].computedHeight,
                marginAxisRow,
                marginAxisColumn,
                node->getConfig())) {
          cachedResults = &layout->cachedMeasurements[i];
          break;
        }
      }
    }
  } else if (performLayout) {
    if (yoga::inexactEquals(
            layout->cachedLayout.availableWidth, availableWidth) &&
        yoga::inexactEquals(
            layout->cachedLayout.availableHeight, availableHeight) &&
<<<<<<< HEAD
        layout->cachedLayout.widthSizingMode == widthSizingMode &&
        layout->cachedLayout.heightSizingMode == heightSizingMode) {
=======
        layout->cachedLayout.widthMeasureMode == widthMeasureMode &&
        layout->cachedLayout.heightMeasureMode == heightMeasureMode) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
      cachedResults = &layout->cachedLayout;
    }
  } else {
    for (uint32_t i = 0; i < layout->nextCachedMeasurementsIndex; i++) {
      if (yoga::inexactEquals(
              layout->cachedMeasurements[i].availableWidth, availableWidth) &&
          yoga::inexactEquals(
              layout->cachedMeasurements[i].availableHeight, availableHeight) &&
<<<<<<< HEAD
          layout->cachedMeasurements[i].widthSizingMode == widthSizingMode &&
          layout->cachedMeasurements[i].heightSizingMode == heightSizingMode) {
=======
          layout->cachedMeasurements[i].widthMeasureMode == widthMeasureMode &&
          layout->cachedMeasurements[i].heightMeasureMode ==
              heightMeasureMode) {
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        cachedResults = &layout->cachedMeasurements[i];
        break;
      }
    }
  }

  if (!needToVisitNode && cachedResults != nullptr) {
    layout->setMeasuredDimension(
<<<<<<< HEAD
        Dimension::Width, cachedResults->computedWidth);
    layout->setMeasuredDimension(
        Dimension::Height, cachedResults->computedHeight);

    (performLayout ? layoutMarkerData.cachedLayouts
                   : layoutMarkerData.cachedMeasures) += 1;
  } else {
=======
        YGDimensionWidth, cachedResults->computedWidth);
    layout->setMeasuredDimension(
        YGDimensionHeight, cachedResults->computedHeight);

    (performLayout ? layoutMarkerData.cachedLayouts
                   : layoutMarkerData.cachedMeasures) += 1;

    if (gPrintChanges && gPrintSkips) {
      yoga::log(
          node,
          LogLevel::Verbose,
          "%s%d.{[skipped] ",
          spacerWithLength(depth),
          depth);
      node->print();
      yoga::log(
          node,
          LogLevel::Verbose,
          "wm: %s, hm: %s, aw: %f ah: %f => d: (%f, %f) %s\n",
          measureModeName(widthMeasureMode, performLayout),
          measureModeName(heightMeasureMode, performLayout),
          availableWidth,
          availableHeight,
          cachedResults->computedWidth,
          cachedResults->computedHeight,
          LayoutPassReasonToString(reason));
    }
  } else {
    if (gPrintChanges) {
      yoga::log(
          node,
          LogLevel::Verbose,
          "%s%d.{%s",
          spacerWithLength(depth),
          depth,
          needToVisitNode ? "*" : "");
      node->print();
      yoga::log(
          node,
          LogLevel::Verbose,
          "wm: %s, hm: %s, aw: %f ah: %f %s\n",
          measureModeName(widthMeasureMode, performLayout),
          measureModeName(heightMeasureMode, performLayout),
          availableWidth,
          availableHeight,
          LayoutPassReasonToString(reason));
    }

>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    calculateLayoutImpl(
        node,
        availableWidth,
        availableHeight,
        ownerDirection,
<<<<<<< HEAD
        widthSizingMode,
        heightSizingMode,
=======
        widthMeasureMode,
        heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        ownerWidth,
        ownerHeight,
        performLayout,
        layoutMarkerData,
        depth,
        generationCount,
        reason);

<<<<<<< HEAD
=======
    if (gPrintChanges) {
      yoga::log(
          node,
          LogLevel::Verbose,
          "%s%d.}%s",
          spacerWithLength(depth),
          depth,
          needToVisitNode ? "*" : "");
      node->print();
      yoga::log(
          node,
          LogLevel::Verbose,
          "wm: %s, hm: %s, d: (%f, %f) %s\n",
          measureModeName(widthMeasureMode, performLayout),
          measureModeName(heightMeasureMode, performLayout),
          layout->measuredDimension(YGDimensionWidth),
          layout->measuredDimension(YGDimensionHeight),
          LayoutPassReasonToString(reason));
    }

>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    layout->lastOwnerDirection = ownerDirection;

    if (cachedResults == nullptr) {
      layoutMarkerData.maxMeasureCache = std::max(
          layoutMarkerData.maxMeasureCache,
          layout->nextCachedMeasurementsIndex + 1u);

      if (layout->nextCachedMeasurementsIndex ==
          LayoutResults::MaxCachedMeasurements) {
<<<<<<< HEAD
=======
        if (gPrintChanges) {
          yoga::log(node, LogLevel::Verbose, "Out of cache entries!\n");
        }
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
        layout->nextCachedMeasurementsIndex = 0;
      }

      CachedMeasurement* newCacheEntry;
      if (performLayout) {
        // Use the single layout cache entry.
        newCacheEntry = &layout->cachedLayout;
      } else {
        // Allocate a new measurement cache entry.
        newCacheEntry =
            &layout->cachedMeasurements[layout->nextCachedMeasurementsIndex];
        layout->nextCachedMeasurementsIndex++;
      }

      newCacheEntry->availableWidth = availableWidth;
      newCacheEntry->availableHeight = availableHeight;
<<<<<<< HEAD
      newCacheEntry->widthSizingMode = widthSizingMode;
      newCacheEntry->heightSizingMode = heightSizingMode;
      newCacheEntry->computedWidth =
          layout->measuredDimension(Dimension::Width);
      newCacheEntry->computedHeight =
          layout->measuredDimension(Dimension::Height);
=======
      newCacheEntry->widthMeasureMode = widthMeasureMode;
      newCacheEntry->heightMeasureMode = heightMeasureMode;
      newCacheEntry->computedWidth =
          layout->measuredDimension(YGDimensionWidth);
      newCacheEntry->computedHeight =
          layout->measuredDimension(YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
    }
  }

  if (performLayout) {
    node->setLayoutDimension(
<<<<<<< HEAD
        node->getLayout().measuredDimension(Dimension::Width),
        Dimension::Width);
    node->setLayoutDimension(
        node->getLayout().measuredDimension(Dimension::Height),
        Dimension::Height);
=======
        node->getLayout().measuredDimension(YGDimensionWidth),
        YGDimensionWidth);
    node->setLayoutDimension(
        node->getLayout().measuredDimension(YGDimensionHeight),
        YGDimensionHeight);
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615

    node->setHasNewLayout(true);
    node->setDirty(false);
  }

  layout->generationCount = generationCount;

  LayoutType layoutType;
  if (performLayout) {
    layoutType = !needToVisitNode && cachedResults == &layout->cachedLayout
        ? LayoutType::kCachedLayout
        : LayoutType::kLayout;
  } else {
    layoutType = cachedResults != nullptr ? LayoutType::kCachedMeasure
                                          : LayoutType::kMeasure;
  }
  Event::publish<Event::NodeLayout>(node, {layoutType});

  return (needToVisitNode || cachedResults == nullptr);
}

void calculateLayout(
    yoga::Node* const node,
    const float ownerWidth,
    const float ownerHeight,
    const Direction ownerDirection) {
  Event::publish<Event::LayoutPassStart>(node);
  LayoutData markerData = {};

  // Increment the generation count. This will force the recursive routine to
  // visit all dirty nodes at least once. Subsequent visits will be skipped if
  // the input parameters don't change.
  gCurrentGenerationCount.fetch_add(1, std::memory_order_relaxed);
  node->resolveDimension();
  float width = YGUndefined;
<<<<<<< HEAD
  SizingMode widthSizingMode = SizingMode::MaxContent;
  const auto& style = node->style();
  if (node->hasDefiniteLength(Dimension::Width, ownerWidth)) {
    width =
        (node->getResolvedDimension(dimension(FlexDirection::Row))
             .resolve(ownerWidth)
             .unwrap() +
         node->style().computeMarginForAxis(FlexDirection::Row, ownerWidth));
    widthSizingMode = SizingMode::StretchFit;
  } else if (style.maxDimension(Dimension::Width)
                 .resolve(ownerWidth)
                 .isDefined()) {
    width = style.maxDimension(Dimension::Width).resolve(ownerWidth).unwrap();
    widthSizingMode = SizingMode::FitContent;
  } else {
    width = ownerWidth;
    widthSizingMode = yoga::isUndefined(width) ? SizingMode::MaxContent
                                               : SizingMode::StretchFit;
  }

  float height = YGUndefined;
  SizingMode heightSizingMode = SizingMode::MaxContent;
  if (node->hasDefiniteLength(Dimension::Height, ownerHeight)) {
    height =
        (node->getResolvedDimension(dimension(FlexDirection::Column))
             .resolve(ownerHeight)
             .unwrap() +
         node->style().computeMarginForAxis(FlexDirection::Column, ownerWidth));
    heightSizingMode = SizingMode::StretchFit;
  } else if (style.maxDimension(Dimension::Height)
                 .resolve(ownerHeight)
                 .isDefined()) {
    height =
        style.maxDimension(Dimension::Height).resolve(ownerHeight).unwrap();
    heightSizingMode = SizingMode::FitContent;
  } else {
    height = ownerHeight;
    heightSizingMode = yoga::isUndefined(height) ? SizingMode::MaxContent
                                                 : SizingMode::StretchFit;
=======
  MeasureMode widthMeasureMode = MeasureMode::Undefined;
  const auto& style = node->getStyle();
  if (styleDefinesDimension(node, FlexDirection::Row, ownerWidth)) {
    width = (yoga::resolveValue(
                 node->getResolvedDimension(dimension(FlexDirection::Row)),
                 ownerWidth) +
             node->getMarginForAxis(FlexDirection::Row, ownerWidth))
                .unwrap();
    widthMeasureMode = MeasureMode::Exactly;
  } else if (!yoga::resolveValue(
                  style.maxDimension(YGDimensionWidth), ownerWidth)
                  .isUndefined()) {
    width = yoga::resolveValue(style.maxDimension(YGDimensionWidth), ownerWidth)
                .unwrap();
    widthMeasureMode = MeasureMode::AtMost;
  } else {
    width = ownerWidth;
    widthMeasureMode = yoga::isUndefined(width) ? MeasureMode::Undefined
                                                : MeasureMode::Exactly;
  }

  float height = YGUndefined;
  MeasureMode heightMeasureMode = MeasureMode::Undefined;
  if (styleDefinesDimension(node, FlexDirection::Column, ownerHeight)) {
    height = (yoga::resolveValue(
                  node->getResolvedDimension(dimension(FlexDirection::Column)),
                  ownerHeight) +
              node->getMarginForAxis(FlexDirection::Column, ownerWidth))
                 .unwrap();
    heightMeasureMode = MeasureMode::Exactly;
  } else if (!yoga::resolveValue(
                  style.maxDimension(YGDimensionHeight), ownerHeight)
                  .isUndefined()) {
    height =
        yoga::resolveValue(style.maxDimension(YGDimensionHeight), ownerHeight)
            .unwrap();
    heightMeasureMode = MeasureMode::AtMost;
  } else {
    height = ownerHeight;
    heightMeasureMode = yoga::isUndefined(height) ? MeasureMode::Undefined
                                                  : MeasureMode::Exactly;
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }
  if (calculateLayoutInternal(
          node,
          width,
          height,
          ownerDirection,
<<<<<<< HEAD
          widthSizingMode,
          heightSizingMode,
=======
          widthMeasureMode,
          heightMeasureMode,
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
          ownerWidth,
          ownerHeight,
          true,
          LayoutPassReason::kInitial,
          markerData,
          0, // tree root
          gCurrentGenerationCount.load(std::memory_order_relaxed))) {
    node->setPosition(
        node->getLayout().direction(), ownerWidth, ownerHeight, ownerWidth);
    roundLayoutResultsToPixelGrid(node, 0.0f, 0.0f);
<<<<<<< HEAD
=======

#ifdef DEBUG
    if (node->getConfig()->shouldPrintTree()) {
      yoga::print(
          node,
          PrintOptions::Layout | PrintOptions::Children | PrintOptions::Style);
    }
#endif
>>>>>>> d8fbf97a591e21830818fb4b5745c614f0d90615
  }

  Event::publish<Event::LayoutPassEnd>(node, {&markerData});
}

} // namespace facebook::yoga
